/*
FOSSA API

OpenAPI Specification for public FOSSA APIs

API version: 4.28.61
Contact: support@fossa.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fossa

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"time"
	"reflect"
)


// AuditLogsAPIService AuditLogsAPI service
type AuditLogsAPIService service

type ApiGetAuditLogsRequest struct {
	ctx context.Context
	ApiService *AuditLogsAPIService
	offset *int32
	limit *int32
	sortBy *string
	sortDir *string
	startDate *time.Time
	endDate *time.Time
	actingUserIds *[]string
	actions *[]string
	topics *[]string
	topicActions *[]string
	startingAfter *time.Time
	endingBefore *string
}

// The number of records to skip
func (r ApiGetAuditLogsRequest) Offset(offset int32) ApiGetAuditLogsRequest {
	r.offset = &offset
	return r
}

// The number of records to return
func (r ApiGetAuditLogsRequest) Limit(limit int32) ApiGetAuditLogsRequest {
	r.limit = &limit
	return r
}

// The field to sort by (defaults to createdAt)
func (r ApiGetAuditLogsRequest) SortBy(sortBy string) ApiGetAuditLogsRequest {
	r.sortBy = &sortBy
	return r
}

// The direction to sort by (defaults to DESC)
func (r ApiGetAuditLogsRequest) SortDir(sortDir string) ApiGetAuditLogsRequest {
	r.sortDir = &sortDir
	return r
}

// The start date to filter audit logs to
func (r ApiGetAuditLogsRequest) StartDate(startDate time.Time) ApiGetAuditLogsRequest {
	r.startDate = &startDate
	return r
}

// The end date to filter audit logs to
func (r ApiGetAuditLogsRequest) EndDate(endDate time.Time) ApiGetAuditLogsRequest {
	r.endDate = &endDate
	return r
}

// The acting user IDs to filter audit logs to
func (r ApiGetAuditLogsRequest) ActingUserIds(actingUserIds []string) ApiGetAuditLogsRequest {
	r.actingUserIds = &actingUserIds
	return r
}

// The actions to filter audit logs to
func (r ApiGetAuditLogsRequest) Actions(actions []string) ApiGetAuditLogsRequest {
	r.actions = &actions
	return r
}

// The topics to filter audit logs to
func (r ApiGetAuditLogsRequest) Topics(topics []string) ApiGetAuditLogsRequest {
	r.topics = &topics
	return r
}

// The topic actions to filter audit logs to
func (r ApiGetAuditLogsRequest) TopicActions(topicActions []string) ApiGetAuditLogsRequest {
	r.topicActions = &topicActions
	return r
}

// The id to start after to filter audit logs to
func (r ApiGetAuditLogsRequest) StartingAfter(startingAfter time.Time) ApiGetAuditLogsRequest {
	r.startingAfter = &startingAfter
	return r
}

// The id to end before to filter audit logs to
func (r ApiGetAuditLogsRequest) EndingBefore(endingBefore string) ApiGetAuditLogsRequest {
	r.endingBefore = &endingBefore
	return r
}

func (r ApiGetAuditLogsRequest) Execute() ([]GetAuditLogs200ResponseInner, *http.Response, error) {
	return r.ApiService.GetAuditLogsExecute(r)
}

/*
GetAuditLogs Method for GetAuditLogs

Retrieves a list of audit logs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAuditLogsRequest
*/
func (a *AuditLogsAPIService) GetAuditLogs(ctx context.Context) ApiGetAuditLogsRequest {
	return ApiGetAuditLogsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GetAuditLogs200ResponseInner
func (a *AuditLogsAPIService) GetAuditLogsExecute(r ApiGetAuditLogsRequest) ([]GetAuditLogs200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetAuditLogs200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditLogsAPIService.GetAuditLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit_logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	}
	if r.sortDir != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortDir", r.sortDir, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.actingUserIds != nil {
		t := *r.actingUserIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actingUserIds[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actingUserIds[]", t, "form", "multi")
		}
	}
	if r.actions != nil {
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions[]", t, "form", "multi")
		}
	}
	if r.topics != nil {
		t := *r.topics
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "topics[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "topics[]", t, "form", "multi")
		}
	}
	if r.topicActions != nil {
		t := *r.topicActions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "topicActions[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "topicActions[]", t, "form", "multi")
		}
	}
	if r.startingAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startingAfter", r.startingAfter, "form", "")
	}
	if r.endingBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endingBefore", r.endingBefore, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAuditLogsCountRequest struct {
	ctx context.Context
	ApiService *AuditLogsAPIService
	offset *int32
	limit *int32
	sortBy *string
	sortDir *string
	startDate *time.Time
	endDate *time.Time
	actingUserIds *[]string
	actions *[]string
	topics *[]string
	topicActions *[]string
	startingAfter *time.Time
	endingBefore *string
}

// The number of records to skip
func (r ApiGetAuditLogsCountRequest) Offset(offset int32) ApiGetAuditLogsCountRequest {
	r.offset = &offset
	return r
}

// The number of records to return
func (r ApiGetAuditLogsCountRequest) Limit(limit int32) ApiGetAuditLogsCountRequest {
	r.limit = &limit
	return r
}

// The field to sort by (defaults to createdAt)
func (r ApiGetAuditLogsCountRequest) SortBy(sortBy string) ApiGetAuditLogsCountRequest {
	r.sortBy = &sortBy
	return r
}

// The direction to sort by (defaults to DESC)
func (r ApiGetAuditLogsCountRequest) SortDir(sortDir string) ApiGetAuditLogsCountRequest {
	r.sortDir = &sortDir
	return r
}

// The start date to filter audit logs to
func (r ApiGetAuditLogsCountRequest) StartDate(startDate time.Time) ApiGetAuditLogsCountRequest {
	r.startDate = &startDate
	return r
}

// The end date to filter audit logs to
func (r ApiGetAuditLogsCountRequest) EndDate(endDate time.Time) ApiGetAuditLogsCountRequest {
	r.endDate = &endDate
	return r
}

// The acting user IDs to filter audit logs to
func (r ApiGetAuditLogsCountRequest) ActingUserIds(actingUserIds []string) ApiGetAuditLogsCountRequest {
	r.actingUserIds = &actingUserIds
	return r
}

// The actions to filter audit logs to
func (r ApiGetAuditLogsCountRequest) Actions(actions []string) ApiGetAuditLogsCountRequest {
	r.actions = &actions
	return r
}

// The topics to filter audit logs to
func (r ApiGetAuditLogsCountRequest) Topics(topics []string) ApiGetAuditLogsCountRequest {
	r.topics = &topics
	return r
}

// The topic actions to filter audit logs to
func (r ApiGetAuditLogsCountRequest) TopicActions(topicActions []string) ApiGetAuditLogsCountRequest {
	r.topicActions = &topicActions
	return r
}

// The id to start after to filter audit logs to
func (r ApiGetAuditLogsCountRequest) StartingAfter(startingAfter time.Time) ApiGetAuditLogsCountRequest {
	r.startingAfter = &startingAfter
	return r
}

// The id to end before to filter audit logs to
func (r ApiGetAuditLogsCountRequest) EndingBefore(endingBefore string) ApiGetAuditLogsCountRequest {
	r.endingBefore = &endingBefore
	return r
}

func (r ApiGetAuditLogsCountRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.GetAuditLogsCountExecute(r)
}

/*
GetAuditLogsCount Method for GetAuditLogsCount

Retrieves a count of audit logs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAuditLogsCountRequest
*/
func (a *AuditLogsAPIService) GetAuditLogsCount(ctx context.Context) ApiGetAuditLogsCountRequest {
	return ApiGetAuditLogsCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int32
func (a *AuditLogsAPIService) GetAuditLogsCountExecute(r ApiGetAuditLogsCountRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditLogsAPIService.GetAuditLogsCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/count/audit_logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	}
	if r.sortDir != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortDir", r.sortDir, "form", "")
	}
	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.actingUserIds != nil {
		t := *r.actingUserIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actingUserIds[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actingUserIds[]", t, "form", "multi")
		}
	}
	if r.actions != nil {
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions[]", t, "form", "multi")
		}
	}
	if r.topics != nil {
		t := *r.topics
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "topics[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "topics[]", t, "form", "multi")
		}
	}
	if r.topicActions != nil {
		t := *r.topicActions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "topicActions[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "topicActions[]", t, "form", "multi")
		}
	}
	if r.startingAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startingAfter", r.startingAfter, "form", "")
	}
	if r.endingBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endingBefore", r.endingBefore, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAuditLogsExportRequest struct {
	ctx context.Context
	ApiService *AuditLogsAPIService
	getAuditLogsExportRequest *GetAuditLogsExportRequest
}

func (r ApiGetAuditLogsExportRequest) GetAuditLogsExportRequest(getAuditLogsExportRequest GetAuditLogsExportRequest) ApiGetAuditLogsExportRequest {
	r.getAuditLogsExportRequest = &getAuditLogsExportRequest
	return r
}

func (r ApiGetAuditLogsExportRequest) Execute() (*GetAuditLogsExport201Response, *http.Response, error) {
	return r.ApiService.GetAuditLogsExportExecute(r)
}

/*
GetAuditLogsExport Method for GetAuditLogsExport

Request an export of audit logs. The export will be generated asynchronously and a link to download the CSV file will be emailed to you.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAuditLogsExportRequest
*/
func (a *AuditLogsAPIService) GetAuditLogsExport(ctx context.Context) ApiGetAuditLogsExportRequest {
	return ApiGetAuditLogsExportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAuditLogsExport201Response
func (a *AuditLogsAPIService) GetAuditLogsExportExecute(r ApiGetAuditLogsExportRequest) (*GetAuditLogsExport201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAuditLogsExport201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditLogsAPIService.GetAuditLogsExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit_logs/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getAuditLogsExportRequest == nil {
		return localVarReturnValue, nil, reportError("getAuditLogsExportRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getAuditLogsExportRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
