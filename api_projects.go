/*
FOSSA API

OpenAPI Specification for public FOSSA APIs

API version: 4.28.61
Contact: support@fossa.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fossa

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ProjectsAPIService ProjectsAPI service
type ProjectsAPIService service

type ApiDeleteProjectGenerateAttributionSlugRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	locator string
}

func (r ApiDeleteProjectGenerateAttributionSlugRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteProjectGenerateAttributionSlugExecute(r)
}

/*
DeleteProjectGenerateAttributionSlug Method for DeleteProjectGenerateAttributionSlug

Delete a slug used in the URL for the live attribution report for this project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator
 @return ApiDeleteProjectGenerateAttributionSlugRequest
*/
func (a *ProjectsAPIService) DeleteProjectGenerateAttributionSlug(ctx context.Context, locator string) ApiDeleteProjectGenerateAttributionSlugRequest {
	return ApiDeleteProjectGenerateAttributionSlugRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
func (a *ProjectsAPIService) DeleteProjectGenerateAttributionSlugExecute(r ApiDeleteProjectGenerateAttributionSlugRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.DeleteProjectGenerateAttributionSlug")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{locator}/generate_attribution_slug"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteProjectsRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	title *string
	type_ *string
	isPublic *bool
	labels *[]string
	teamId *[]GetIssueCWEsTeamIdParameterInner
	latestScan *int32
	lastRevisionWithin *int32
	locators *DeleteProjectsLocatorsParameter
}

// Filter by project name.
func (r ApiDeleteProjectsRequest) Title(title string) ApiDeleteProjectsRequest {
	r.title = &title
	return r
}

// Filter by project type.
func (r ApiDeleteProjectsRequest) Type_(type_ string) ApiDeleteProjectsRequest {
	r.type_ = &type_
	return r
}

// Filter by project being public or private.
func (r ApiDeleteProjectsRequest) IsPublic(isPublic bool) ApiDeleteProjectsRequest {
	r.isPublic = &isPublic
	return r
}

// Filter by project labels.
func (r ApiDeleteProjectsRequest) Labels(labels []string) ApiDeleteProjectsRequest {
	r.labels = &labels
	return r
}

// Filter by one or more team IDs. Providing \&quot;null\&quot; will return all unassigned projects.
func (r ApiDeleteProjectsRequest) TeamId(teamId []GetIssueCWEsTeamIdParameterInner) ApiDeleteProjectsRequest {
	r.teamId = &teamId
	return r
}

// Filter by last policy scan within N days.
func (r ApiDeleteProjectsRequest) LatestScan(latestScan int32) ApiDeleteProjectsRequest {
	r.latestScan = &latestScan
	return r
}

// Filter by last revision analyzed within N days.
func (r ApiDeleteProjectsRequest) LastRevisionWithin(lastRevisionWithin int32) ApiDeleteProjectsRequest {
	r.lastRevisionWithin = &lastRevisionWithin
	return r
}

// The list of locators for the projects to delete. If \&quot;all\&quot; is provided, then all projects that meet the provided filters will be deleted. 
func (r ApiDeleteProjectsRequest) Locators(locators DeleteProjectsLocatorsParameter) ApiDeleteProjectsRequest {
	r.locators = &locators
	return r
}

func (r ApiDeleteProjectsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteProjectsExecute(r)
}

/*
DeleteProjects Method for DeleteProjects

Delete projects from an organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteProjectsRequest
*/
func (a *ProjectsAPIService) DeleteProjects(ctx context.Context) ApiDeleteProjectsRequest {
	return ApiDeleteProjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ProjectsAPIService) DeleteProjectsExecute(r ApiDeleteProjectsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.DeleteProjects")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.isPublic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isPublic", r.isPublic, "form", "")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels[]", t, "form", "multi")
		}
	}
	if r.teamId != nil {
		t := *r.teamId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teamId[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teamId[]", t, "form", "multi")
		}
	}
	if r.latestScan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestScan", r.latestScan, "form", "")
	}
	if r.lastRevisionWithin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastRevisionWithin", r.lastRevisionWithin, "form", "")
	}
	if r.locators != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locators", r.locators, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteReleaseGroupsRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	title *string
	teamId *[]GetIssueCWEsTeamIdParameterInner
	latestScan *int32
	ids *DeleteReleaseGroupsIdsParameter
}

// Filter by release group name.
func (r ApiDeleteReleaseGroupsRequest) Title(title string) ApiDeleteReleaseGroupsRequest {
	r.title = &title
	return r
}

// Filter by one or more team IDs. Providing \&quot;null\&quot; will return all unassigned release groups.
func (r ApiDeleteReleaseGroupsRequest) TeamId(teamId []GetIssueCWEsTeamIdParameterInner) ApiDeleteReleaseGroupsRequest {
	r.teamId = &teamId
	return r
}

// Filter by last policy scan within N days.
func (r ApiDeleteReleaseGroupsRequest) LatestScan(latestScan int32) ApiDeleteReleaseGroupsRequest {
	r.latestScan = &latestScan
	return r
}

// The list of ids for the release groups to delete. If \&quot;all\&quot; is provided, then all release groups that meet the provided filters will be deleted. 
func (r ApiDeleteReleaseGroupsRequest) Ids(ids DeleteReleaseGroupsIdsParameter) ApiDeleteReleaseGroupsRequest {
	r.ids = &ids
	return r
}

func (r ApiDeleteReleaseGroupsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteReleaseGroupsExecute(r)
}

/*
DeleteReleaseGroups Method for DeleteReleaseGroups

Delete release groups from an organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteReleaseGroupsRequest
*/
func (a *ProjectsAPIService) DeleteReleaseGroups(ctx context.Context) ApiDeleteReleaseGroupsRequest {
	return ApiDeleteReleaseGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ProjectsAPIService) DeleteReleaseGroupsExecute(r ApiDeleteReleaseGroupsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.DeleteReleaseGroups")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/release-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.teamId != nil {
		t := *r.teamId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teamId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teamId", t, "form", "multi")
		}
	}
	if r.latestScan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestScan", r.latestScan, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGenerateProjectGenerateAttributionSlugRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	locator string
}

func (r ApiGenerateProjectGenerateAttributionSlugRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GenerateProjectGenerateAttributionSlugExecute(r)
}

/*
GenerateProjectGenerateAttributionSlug Method for GenerateProjectGenerateAttributionSlug

Generate (or regenerate) a slug used in the URL for the live attribution report for this project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator
 @return ApiGenerateProjectGenerateAttributionSlugRequest
*/
func (a *ProjectsAPIService) GenerateProjectGenerateAttributionSlug(ctx context.Context, locator string) ApiGenerateProjectGenerateAttributionSlugRequest {
	return ApiGenerateProjectGenerateAttributionSlugRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
//  @return string
func (a *ProjectsAPIService) GenerateProjectGenerateAttributionSlugExecute(r ApiGenerateProjectGenerateAttributionSlugRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.GenerateProjectGenerateAttributionSlug")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{locator}/generate_attribution_slug"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GenerateProjectGenerateAttributionSlug401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectCSVExportIssuesRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	locator string
	revisionId *string
	status *interface{}
	ref *string
	refType *string
}

// The revisionId of the project to get issues for. If not provided, the latest revision will be used.
func (r ApiGetProjectCSVExportIssuesRequest) RevisionId(revisionId string) ApiGetProjectCSVExportIssuesRequest {
	r.revisionId = &revisionId
	return r
}

// The status of the issues to return. If not provided, all active issues will be returned.
func (r ApiGetProjectCSVExportIssuesRequest) Status(status interface{}) ApiGetProjectCSVExportIssuesRequest {
	r.status = &status
	return r
}

// the branch or tag to get issues for. If not provided, the default branch will be used.
func (r ApiGetProjectCSVExportIssuesRequest) Ref(ref string) ApiGetProjectCSVExportIssuesRequest {
	r.ref = &ref
	return r
}

// Specify whether the ref is a branch or tag.
func (r ApiGetProjectCSVExportIssuesRequest) RefType(refType string) ApiGetProjectCSVExportIssuesRequest {
	r.refType = &refType
	return r
}

func (r ApiGetProjectCSVExportIssuesRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetProjectCSVExportIssuesExecute(r)
}

/*
GetProjectCSVExportIssues Method for GetProjectCSVExportIssues

This endpoint returns a CSV file of all issues for the project.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator the url-encoded locator of the project
 @return ApiGetProjectCSVExportIssuesRequest
*/
func (a *ProjectsAPIService) GetProjectCSVExportIssues(ctx context.Context, locator string) ApiGetProjectCSVExportIssuesRequest {
	return ApiGetProjectCSVExportIssuesRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
//  @return string
func (a *ProjectsAPIService) GetProjectCSVExportIssuesExecute(r ApiGetProjectCSVExportIssuesRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.GetProjectCSVExportIssues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{locator}/export-issues/csv"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.revisionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revisionId", r.revisionId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.ref != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ref", r.ref, "form", "")
	}
	if r.refType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ref_type", r.refType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectExportIssuesRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	locator string
	format *interface{}
	revisionId *string
	status *interface{}
	ref *string
	refType *string
}

// report format to return (JSON or CSV). If not provided, JSON will be returned.
func (r ApiGetProjectExportIssuesRequest) Format(format interface{}) ApiGetProjectExportIssuesRequest {
	r.format = &format
	return r
}

// The revisionId of the project to get issues for. If not provided, the latest revision will be used.
func (r ApiGetProjectExportIssuesRequest) RevisionId(revisionId string) ApiGetProjectExportIssuesRequest {
	r.revisionId = &revisionId
	return r
}

// The status of the issues to return. If not provided, all active issues will be returned.
func (r ApiGetProjectExportIssuesRequest) Status(status interface{}) ApiGetProjectExportIssuesRequest {
	r.status = &status
	return r
}

// the branch or tag to get issues for. If not provided, the default branch will be used.
func (r ApiGetProjectExportIssuesRequest) Ref(ref string) ApiGetProjectExportIssuesRequest {
	r.ref = &ref
	return r
}

// Specify whether the ref is a branch or tag.
func (r ApiGetProjectExportIssuesRequest) RefType(refType string) ApiGetProjectExportIssuesRequest {
	r.refType = &refType
	return r
}

func (r ApiGetProjectExportIssuesRequest) Execute() (*GetProjectExportIssues200Response, *http.Response, error) {
	return r.ApiService.GetProjectExportIssuesExecute(r)
}

/*
GetProjectExportIssues Method for GetProjectExportIssues

This endpoint returns a list of all issues for a project. The issues are exported in a JSON (or CSV) format.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator the url-encoded locator of the project
 @return ApiGetProjectExportIssuesRequest
*/
func (a *ProjectsAPIService) GetProjectExportIssues(ctx context.Context, locator string) ApiGetProjectExportIssuesRequest {
	return ApiGetProjectExportIssuesRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
//  @return GetProjectExportIssues200Response
func (a *ProjectsAPIService) GetProjectExportIssuesExecute(r ApiGetProjectExportIssuesRequest) (*GetProjectExportIssues200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProjectExportIssues200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.GetProjectExportIssues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{locator}/export-issues"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.revisionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revisionId", r.revisionId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.ref != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ref", r.ref, "form", "")
	}
	if r.refType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ref_type", r.refType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectJSONExportIssuesRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	locator string
	revisionId *string
	status *interface{}
	ref *string
	refType *string
}

// The revisionId of the project to get issues for. If not provided, the latest revision will be used.
func (r ApiGetProjectJSONExportIssuesRequest) RevisionId(revisionId string) ApiGetProjectJSONExportIssuesRequest {
	r.revisionId = &revisionId
	return r
}

// The status of the issues to return. If not provided, all active issues will be returned.
func (r ApiGetProjectJSONExportIssuesRequest) Status(status interface{}) ApiGetProjectJSONExportIssuesRequest {
	r.status = &status
	return r
}

// the branch or tag to get issues for. If not provided, the default branch will be used.
func (r ApiGetProjectJSONExportIssuesRequest) Ref(ref string) ApiGetProjectJSONExportIssuesRequest {
	r.ref = &ref
	return r
}

// Specify whether the ref is a branch or tag.
func (r ApiGetProjectJSONExportIssuesRequest) RefType(refType string) ApiGetProjectJSONExportIssuesRequest {
	r.refType = &refType
	return r
}

func (r ApiGetProjectJSONExportIssuesRequest) Execute() (*GetProjectJSONExportIssues200Response, *http.Response, error) {
	return r.ApiService.GetProjectJSONExportIssuesExecute(r)
}

/*
GetProjectJSONExportIssues Method for GetProjectJSONExportIssues

This endpoint returns a list of all issues for a project. The issues are exported in a JSON format.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator the url-encoded locator of the project
 @return ApiGetProjectJSONExportIssuesRequest
*/
func (a *ProjectsAPIService) GetProjectJSONExportIssues(ctx context.Context, locator string) ApiGetProjectJSONExportIssuesRequest {
	return ApiGetProjectJSONExportIssuesRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
//  @return GetProjectJSONExportIssues200Response
func (a *ProjectsAPIService) GetProjectJSONExportIssuesExecute(r ApiGetProjectJSONExportIssuesRequest) (*GetProjectJSONExportIssues200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProjectJSONExportIssues200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.GetProjectJSONExportIssues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{locator}/export-issues/json"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.revisionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revisionId", r.revisionId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.ref != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ref", r.ref, "form", "")
	}
	if r.refType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ref_type", r.refType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectLastPublishedRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	locator string
}

func (r ApiGetProjectLastPublishedRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetProjectLastPublishedExecute(r)
}

/*
GetProjectLastPublished Method for GetProjectLastPublished

Retrieves the timestamp of the last time the project received an update.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator
 @return ApiGetProjectLastPublishedRequest
*/
func (a *ProjectsAPIService) GetProjectLastPublished(ctx context.Context, locator string) ApiGetProjectLastPublishedRequest {
	return ApiGetProjectLastPublishedRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
//  @return string
func (a *ProjectsAPIService) GetProjectLastPublishedExecute(r ApiGetProjectLastPublishedRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.GetProjectLastPublished")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{locator}/last-published"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectRevisionsRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	locator string
	offset *float32
	count *float32
	resolved *bool
	refs *[]string
	refsType *string
	source *string
}

// the number of revisions to skip for pagination (used with \&quot;count\&quot; query parameter)
func (r ApiGetProjectRevisionsRequest) Offset(offset float32) ApiGetProjectRevisionsRequest {
	r.offset = &offset
	return r
}

// the number of revisions to return (maximum of 1000)
func (r ApiGetProjectRevisionsRequest) Count(count float32) ApiGetProjectRevisionsRequest {
	r.count = &count
	return r
}

// If true, we will only return Revisions that have been successfully analyzed by FOSSA (resolved)
func (r ApiGetProjectRevisionsRequest) Resolved(resolved bool) ApiGetProjectRevisionsRequest {
	r.resolved = &resolved
	return r
}

// the list of branches or tags being requested
func (r ApiGetProjectRevisionsRequest) Refs(refs []string) ApiGetProjectRevisionsRequest {
	r.refs = &refs
	return r
}

// Specify whether the list should be tags OR branches
func (r ApiGetProjectRevisionsRequest) RefsType(refsType string) ApiGetProjectRevisionsRequest {
	r.refsType = &refsType
	return r
}

// Filter the revisions by source
func (r ApiGetProjectRevisionsRequest) Source(source string) ApiGetProjectRevisionsRequest {
	r.source = &source
	return r
}

func (r ApiGetProjectRevisionsRequest) Execute() (*GetProjectRevisions200Response, *http.Response, error) {
	return r.ApiService.GetProjectRevisionsExecute(r)
}

/*
GetProjectRevisions Method for GetProjectRevisions

List Revisions for the branches and tags of a given project.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator the url-encoded locator of the project - matched by substring
 @return ApiGetProjectRevisionsRequest
*/
func (a *ProjectsAPIService) GetProjectRevisions(ctx context.Context, locator string) ApiGetProjectRevisionsRequest {
	return ApiGetProjectRevisionsRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
//  @return GetProjectRevisions200Response
func (a *ProjectsAPIService) GetProjectRevisionsExecute(r ApiGetProjectRevisionsRequest) (*GetProjectRevisions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProjectRevisions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.GetProjectRevisions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{locator}/revisions"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.resolved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolved", r.resolved, "form", "")
	}
	if r.refs != nil {
		t := *r.refs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "refs[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "refs[]", t, "form", "multi")
		}
	}
	if r.refsType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refs_type", r.refsType, "form", "")
	}
	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectsRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	sort *string
	page *int32
	count *int32
	title *string
	type_ *string
	isPublic *bool
	labels *[]string
	teamId *[]GetIssueCWEsTeamIdParameterInner
	latestScan *int32
	lastRevisionWithin *int32
	locators *[]string
	includeSharedProjects *bool
	onlyIncludeSharedProjects *bool
	url *string
}

// The category to order the results by and sort direction.
func (r ApiGetProjectsRequest) Sort(sort string) ApiGetProjectsRequest {
	r.sort = &sort
	return r
}

// The specific page of data to return
func (r ApiGetProjectsRequest) Page(page int32) ApiGetProjectsRequest {
	r.page = &page
	return r
}

// The number of items to return in each page of results
func (r ApiGetProjectsRequest) Count(count int32) ApiGetProjectsRequest {
	r.count = &count
	return r
}

// Filter by project name.
func (r ApiGetProjectsRequest) Title(title string) ApiGetProjectsRequest {
	r.title = &title
	return r
}

// Filter by project type.
func (r ApiGetProjectsRequest) Type_(type_ string) ApiGetProjectsRequest {
	r.type_ = &type_
	return r
}

// Filter by project being public or private.
func (r ApiGetProjectsRequest) IsPublic(isPublic bool) ApiGetProjectsRequest {
	r.isPublic = &isPublic
	return r
}

// Filter by project labels.
func (r ApiGetProjectsRequest) Labels(labels []string) ApiGetProjectsRequest {
	r.labels = &labels
	return r
}

// Filter by one or more team IDs. Providing \&quot;null\&quot; will return all unassigned projects.
func (r ApiGetProjectsRequest) TeamId(teamId []GetIssueCWEsTeamIdParameterInner) ApiGetProjectsRequest {
	r.teamId = &teamId
	return r
}

// Filter by last policy scan within N days.
func (r ApiGetProjectsRequest) LatestScan(latestScan int32) ApiGetProjectsRequest {
	r.latestScan = &latestScan
	return r
}

// Filter by last revision analyzed within N days.
func (r ApiGetProjectsRequest) LastRevisionWithin(lastRevisionWithin int32) ApiGetProjectsRequest {
	r.lastRevisionWithin = &lastRevisionWithin
	return r
}

// Filter by project locators (exact match).
func (r ApiGetProjectsRequest) Locators(locators []string) ApiGetProjectsRequest {
	r.locators = &locators
	return r
}

// Include shared projects.
func (r ApiGetProjectsRequest) IncludeSharedProjects(includeSharedProjects bool) ApiGetProjectsRequest {
	r.includeSharedProjects = &includeSharedProjects
	return r
}

// Only show projects that have been shared with other organizations.
func (r ApiGetProjectsRequest) OnlyIncludeSharedProjects(onlyIncludeSharedProjects bool) ApiGetProjectsRequest {
	r.onlyIncludeSharedProjects = &onlyIncludeSharedProjects
	return r
}

// Filter by a project&#39;s URL.
func (r ApiGetProjectsRequest) Url(url string) ApiGetProjectsRequest {
	r.url = &url
	return r
}

func (r ApiGetProjectsRequest) Execute() (*GetProjects200Response, *http.Response, error) {
	return r.ApiService.GetProjectsExecute(r)
}

/*
GetProjects Method for GetProjects

Fetch the list of projects based on provided filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProjectsRequest
*/
func (a *ProjectsAPIService) GetProjects(ctx context.Context) ApiGetProjectsRequest {
	return ApiGetProjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetProjects200Response
func (a *ProjectsAPIService) GetProjectsExecute(r ApiGetProjectsRequest) (*GetProjects200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProjects200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.GetProjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 20
		r.count = &defaultValue
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.isPublic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isPublic", r.isPublic, "form", "")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels[]", t, "form", "multi")
		}
	}
	if r.teamId != nil {
		t := *r.teamId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teamId[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teamId[]", t, "form", "multi")
		}
	}
	if r.latestScan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestScan", r.latestScan, "form", "")
	}
	if r.lastRevisionWithin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastRevisionWithin", r.lastRevisionWithin, "form", "")
	}
	if r.locators != nil {
		t := *r.locators
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "locators[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "locators[]", t, "form", "multi")
		}
	}
	if r.includeSharedProjects != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSharedProjects", r.includeSharedProjects, "form", "")
	}
	if r.onlyIncludeSharedProjects != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "onlyIncludeSharedProjects", r.onlyIncludeSharedProjects, "form", "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectsSummaryRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
}

func (r ApiGetProjectsSummaryRequest) Execute() (*GetProjectsSummary200Response, *http.Response, error) {
	return r.ApiService.GetProjectsSummaryExecute(r)
}

/*
GetProjectsSummary Method for GetProjectsSummary

Summary information about the number of projects and release groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProjectsSummaryRequest
*/
func (a *ProjectsAPIService) GetProjectsSummary(ctx context.Context) ApiGetProjectsSummaryRequest {
	return ApiGetProjectsSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetProjectsSummary200Response
func (a *ProjectsAPIService) GetProjectsSummaryExecute(r ApiGetProjectsSummaryRequest) (*GetProjectsSummary200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProjectsSummary200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.GetProjectsSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReleaseGroupsRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	sort *string
	page *int32
	count *int32
	title *string
	teamId *[]GetIssueCWEsTeamIdParameterInner
	latestScan *int32
	lastRevisionWithin *int32
	isPublic *bool
}

// The category to order the results by and sort direction.
func (r ApiGetReleaseGroupsRequest) Sort(sort string) ApiGetReleaseGroupsRequest {
	r.sort = &sort
	return r
}

// The specific page of data to return
func (r ApiGetReleaseGroupsRequest) Page(page int32) ApiGetReleaseGroupsRequest {
	r.page = &page
	return r
}

// The number of items to return in each page of results
func (r ApiGetReleaseGroupsRequest) Count(count int32) ApiGetReleaseGroupsRequest {
	r.count = &count
	return r
}

// Filter by release group name.
func (r ApiGetReleaseGroupsRequest) Title(title string) ApiGetReleaseGroupsRequest {
	r.title = &title
	return r
}

// Filter by one or more team IDs. Providing \&quot;null\&quot; will return all unassigned release groups.
func (r ApiGetReleaseGroupsRequest) TeamId(teamId []GetIssueCWEsTeamIdParameterInner) ApiGetReleaseGroupsRequest {
	r.teamId = &teamId
	return r
}

// Filter by last policy scan within N days.
func (r ApiGetReleaseGroupsRequest) LatestScan(latestScan int32) ApiGetReleaseGroupsRequest {
	r.latestScan = &latestScan
	return r
}

// Filter by last revision analyzed within N days.
func (r ApiGetReleaseGroupsRequest) LastRevisionWithin(lastRevisionWithin int32) ApiGetReleaseGroupsRequest {
	r.lastRevisionWithin = &lastRevisionWithin
	return r
}

// Filter by whether the release group is public on the portal.
func (r ApiGetReleaseGroupsRequest) IsPublic(isPublic bool) ApiGetReleaseGroupsRequest {
	r.isPublic = &isPublic
	return r
}

func (r ApiGetReleaseGroupsRequest) Execute() (*GetReleaseGroups200Response, *http.Response, error) {
	return r.ApiService.GetReleaseGroupsExecute(r)
}

/*
GetReleaseGroups Method for GetReleaseGroups

Fetch the list of release groups based on provided filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReleaseGroupsRequest
*/
func (a *ProjectsAPIService) GetReleaseGroups(ctx context.Context) ApiGetReleaseGroupsRequest {
	return ApiGetReleaseGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetReleaseGroups200Response
func (a *ProjectsAPIService) GetReleaseGroupsExecute(r ApiGetReleaseGroupsRequest) (*GetReleaseGroups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetReleaseGroups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.GetReleaseGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/release-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 20
		r.count = &defaultValue
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.teamId != nil {
		t := *r.teamId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teamId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teamId", t, "form", "multi")
		}
	}
	if r.latestScan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestScan", r.latestScan, "form", "")
	}
	if r.lastRevisionWithin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastRevisionWithin", r.lastRevisionWithin, "form", "")
	}
	if r.isPublic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isPublic", r.isPublic, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListReleaseGroupsForProjectRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	locator string
}

func (r ApiListReleaseGroupsForProjectRequest) Execute() ([]ListReleaseGroupsForProject200ResponseInner, *http.Response, error) {
	return r.ApiService.ListReleaseGroupsForProjectExecute(r)
}

/*
ListReleaseGroupsForProject Method for ListReleaseGroupsForProject

Returns all of the release groups that this project is a part of.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator the url-encoded locator of the project
 @return ApiListReleaseGroupsForProjectRequest
*/
func (a *ProjectsAPIService) ListReleaseGroupsForProject(ctx context.Context, locator string) ApiListReleaseGroupsForProjectRequest {
	return ApiListReleaseGroupsForProjectRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
//  @return []ListReleaseGroupsForProject200ResponseInner
func (a *ProjectsAPIService) ListReleaseGroupsForProjectExecute(r ApiListReleaseGroupsForProjectRequest) ([]ListReleaseGroupsForProject200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ListReleaseGroupsForProject200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.ListReleaseGroupsForProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{locator}/release-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProjectsLabelsRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	labelId *float32
	locators *DeleteProjectsLocatorsParameter
	title *string
	type_ *string
	isPublic *bool
	labels *[]string
	teamId *[]GetIssueCWEsTeamIdParameterInner
	latestScan *int32
	lastRevisionWithin *int32
}

// The ID of the label you want to apply to projects.
func (r ApiUpdateProjectsLabelsRequest) LabelId(labelId float32) ApiUpdateProjectsLabelsRequest {
	r.labelId = &labelId
	return r
}

// The list of locators for the projects to update. If \&quot;all\&quot; is provided, then all projects that meet the provided filters will have the label applied. 
func (r ApiUpdateProjectsLabelsRequest) Locators(locators DeleteProjectsLocatorsParameter) ApiUpdateProjectsLabelsRequest {
	r.locators = &locators
	return r
}

// Filter by project name.
func (r ApiUpdateProjectsLabelsRequest) Title(title string) ApiUpdateProjectsLabelsRequest {
	r.title = &title
	return r
}

// Filter by project type.
func (r ApiUpdateProjectsLabelsRequest) Type_(type_ string) ApiUpdateProjectsLabelsRequest {
	r.type_ = &type_
	return r
}

// Filter by project being public or private.
func (r ApiUpdateProjectsLabelsRequest) IsPublic(isPublic bool) ApiUpdateProjectsLabelsRequest {
	r.isPublic = &isPublic
	return r
}

// Filter by project labels.
func (r ApiUpdateProjectsLabelsRequest) Labels(labels []string) ApiUpdateProjectsLabelsRequest {
	r.labels = &labels
	return r
}

// Filter by one or more team IDs. Providing \&quot;null\&quot; will return all unassigned projects.
func (r ApiUpdateProjectsLabelsRequest) TeamId(teamId []GetIssueCWEsTeamIdParameterInner) ApiUpdateProjectsLabelsRequest {
	r.teamId = &teamId
	return r
}

// Filter by last policy scan within N days.
func (r ApiUpdateProjectsLabelsRequest) LatestScan(latestScan int32) ApiUpdateProjectsLabelsRequest {
	r.latestScan = &latestScan
	return r
}

// Filter by last revision analyzed within N days.
func (r ApiUpdateProjectsLabelsRequest) LastRevisionWithin(lastRevisionWithin int32) ApiUpdateProjectsLabelsRequest {
	r.lastRevisionWithin = &lastRevisionWithin
	return r
}

func (r ApiUpdateProjectsLabelsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateProjectsLabelsExecute(r)
}

/*
UpdateProjectsLabels Method for UpdateProjectsLabels

Apply a label to one to many projects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateProjectsLabelsRequest
*/
func (a *ProjectsAPIService) UpdateProjectsLabels(ctx context.Context) ApiUpdateProjectsLabelsRequest {
	return ApiUpdateProjectsLabelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProjectsAPIService) UpdateProjectsLabelsExecute(r ApiUpdateProjectsLabelsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.UpdateProjectsLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/labels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.labelId == nil {
		return localVarReturnValue, nil, reportError("labelId is required and must be specified")
	}
	if r.locators == nil {
		return localVarReturnValue, nil, reportError("locators is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "labelId", r.labelId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "locators", r.locators, "form", "")
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.isPublic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isPublic", r.isPublic, "form", "")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels[]", t, "form", "multi")
		}
	}
	if r.teamId != nil {
		t := *r.teamId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teamId[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teamId[]", t, "form", "multi")
		}
	}
	if r.latestScan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestScan", r.latestScan, "form", "")
	}
	if r.lastRevisionWithin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastRevisionWithin", r.lastRevisionWithin, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateProjectsPoliciesRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	policyId *float32
	locators *DeleteProjectsLocatorsParameter
	title *string
	type_ *string
	isPublic *bool
	labels *[]string
	teamId *[]GetIssueCWEsTeamIdParameterInner
	latestScan *int32
	lastRevisionWithin *int32
}

// The ID of the policy you want to apply to projects.
func (r ApiUpdateProjectsPoliciesRequest) PolicyId(policyId float32) ApiUpdateProjectsPoliciesRequest {
	r.policyId = &policyId
	return r
}

// The list of locators for the projects to update. If \&quot;all\&quot; is provided, then all projects that meet the provided filters will have the policy applied. 
func (r ApiUpdateProjectsPoliciesRequest) Locators(locators DeleteProjectsLocatorsParameter) ApiUpdateProjectsPoliciesRequest {
	r.locators = &locators
	return r
}

// Filter by project name.
func (r ApiUpdateProjectsPoliciesRequest) Title(title string) ApiUpdateProjectsPoliciesRequest {
	r.title = &title
	return r
}

// Filter by project type.
func (r ApiUpdateProjectsPoliciesRequest) Type_(type_ string) ApiUpdateProjectsPoliciesRequest {
	r.type_ = &type_
	return r
}

// Filter by project being public or private.
func (r ApiUpdateProjectsPoliciesRequest) IsPublic(isPublic bool) ApiUpdateProjectsPoliciesRequest {
	r.isPublic = &isPublic
	return r
}

// Filter by project labels.
func (r ApiUpdateProjectsPoliciesRequest) Labels(labels []string) ApiUpdateProjectsPoliciesRequest {
	r.labels = &labels
	return r
}

// Filter by one or more team IDs. Providing \&quot;null\&quot; will return all unassigned projects.
func (r ApiUpdateProjectsPoliciesRequest) TeamId(teamId []GetIssueCWEsTeamIdParameterInner) ApiUpdateProjectsPoliciesRequest {
	r.teamId = &teamId
	return r
}

// Filter by last policy scan within N days.
func (r ApiUpdateProjectsPoliciesRequest) LatestScan(latestScan int32) ApiUpdateProjectsPoliciesRequest {
	r.latestScan = &latestScan
	return r
}

// Filter by last revision analyzed within N days.
func (r ApiUpdateProjectsPoliciesRequest) LastRevisionWithin(lastRevisionWithin int32) ApiUpdateProjectsPoliciesRequest {
	r.lastRevisionWithin = &lastRevisionWithin
	return r
}

func (r ApiUpdateProjectsPoliciesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.UpdateProjectsPoliciesExecute(r)
}

/*
UpdateProjectsPolicies Method for UpdateProjectsPolicies

Update the policy for one to many projects.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateProjectsPoliciesRequest
*/
func (a *ProjectsAPIService) UpdateProjectsPolicies(ctx context.Context) ApiUpdateProjectsPoliciesRequest {
	return ApiUpdateProjectsPoliciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProjectsAPIService) UpdateProjectsPoliciesExecute(r ApiUpdateProjectsPoliciesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.UpdateProjectsPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/policy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyId == nil {
		return localVarReturnValue, nil, reportError("policyId is required and must be specified")
	}
	if r.locators == nil {
		return localVarReturnValue, nil, reportError("locators is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "policyId", r.policyId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "locators", r.locators, "form", "")
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.isPublic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isPublic", r.isPublic, "form", "")
	}
	if r.labels != nil {
		t := *r.labels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "labels[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "labels[]", t, "form", "multi")
		}
	}
	if r.teamId != nil {
		t := *r.teamId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teamId[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teamId[]", t, "form", "multi")
		}
	}
	if r.latestScan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestScan", r.latestScan, "form", "")
	}
	if r.lastRevisionWithin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastRevisionWithin", r.lastRevisionWithin, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateReleaseGroupsPoliciesRequest struct {
	ctx context.Context
	ApiService *ProjectsAPIService
	policyId *float32
	ids *UpdateReleaseGroupsPoliciesIdsParameter
	title *string
	teamId *[]GetIssueCWEsTeamIdParameterInner
	latestScan *int32
}

// The ID of the policy you want to apply to projects.
func (r ApiUpdateReleaseGroupsPoliciesRequest) PolicyId(policyId float32) ApiUpdateReleaseGroupsPoliciesRequest {
	r.policyId = &policyId
	return r
}

// The list of IDs for the release groups to update. If \&quot;all\&quot; is provided, then all release groups that meet the provided filters will have the label applied. 
func (r ApiUpdateReleaseGroupsPoliciesRequest) Ids(ids UpdateReleaseGroupsPoliciesIdsParameter) ApiUpdateReleaseGroupsPoliciesRequest {
	r.ids = &ids
	return r
}

// Filter by release group name.
func (r ApiUpdateReleaseGroupsPoliciesRequest) Title(title string) ApiUpdateReleaseGroupsPoliciesRequest {
	r.title = &title
	return r
}

// Filter by one or more team IDs. Providing \&quot;null\&quot; will return all unassigned release groups.
func (r ApiUpdateReleaseGroupsPoliciesRequest) TeamId(teamId []GetIssueCWEsTeamIdParameterInner) ApiUpdateReleaseGroupsPoliciesRequest {
	r.teamId = &teamId
	return r
}

// Filter by last policy scan within N days.
func (r ApiUpdateReleaseGroupsPoliciesRequest) LatestScan(latestScan int32) ApiUpdateReleaseGroupsPoliciesRequest {
	r.latestScan = &latestScan
	return r
}

func (r ApiUpdateReleaseGroupsPoliciesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateReleaseGroupsPoliciesExecute(r)
}

/*
UpdateReleaseGroupsPolicies Method for UpdateReleaseGroupsPolicies

Update a policy for one to many release groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateReleaseGroupsPoliciesRequest
*/
func (a *ProjectsAPIService) UpdateReleaseGroupsPolicies(ctx context.Context) ApiUpdateReleaseGroupsPoliciesRequest {
	return ApiUpdateReleaseGroupsPoliciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ProjectsAPIService) UpdateReleaseGroupsPoliciesExecute(r ApiUpdateReleaseGroupsPoliciesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectsAPIService.UpdateReleaseGroupsPolicies")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/release-groups/policy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyId == nil {
		return nil, reportError("policyId is required and must be specified")
	}
	if r.ids == nil {
		return nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "policyId", r.policyId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.teamId != nil {
		t := *r.teamId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teamId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teamId", t, "form", "multi")
		}
	}
	if r.latestScan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestScan", r.latestScan, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
