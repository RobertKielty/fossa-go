/*
FOSSA API

OpenAPI Specification for public FOSSA APIs

API version: 4.28.61
Contact: support@fossa.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fossa

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"reflect"
)


// RevisionsAPIService RevisionsAPI service
type RevisionsAPIService service

type ApiFixPlansRequest struct {
	ctx context.Context
	ApiService *RevisionsAPIService
	locator string
	preview *bool
	format *string
	bundle *bool
	excludeQuickWins *bool
	excludeHighPriority *bool
	excludedLowPriority *bool
	excludeOutdatedDependencies *bool
}

// Whether to preview the report (default is false)
func (r ApiFixPlansRequest) Preview(preview bool) ApiFixPlansRequest {
	r.preview = &preview
	return r
}

// What format to return the report in (default is PDF)
func (r ApiFixPlansRequest) Format(format string) ApiFixPlansRequest {
	r.format = &format
	return r
}

// Whether to bundle the report with json file and return as a zip (default is false)
func (r ApiFixPlansRequest) Bundle(bundle bool) ApiFixPlansRequest {
	r.bundle = &bundle
	return r
}

// Whether to exclude Quick Wins section (default is false)
func (r ApiFixPlansRequest) ExcludeQuickWins(excludeQuickWins bool) ApiFixPlansRequest {
	r.excludeQuickWins = &excludeQuickWins
	return r
}

// Whether to exclude High Priority section (default is false)
func (r ApiFixPlansRequest) ExcludeHighPriority(excludeHighPriority bool) ApiFixPlansRequest {
	r.excludeHighPriority = &excludeHighPriority
	return r
}

// Whether to exclude Low Priority section (default is false)
func (r ApiFixPlansRequest) ExcludedLowPriority(excludedLowPriority bool) ApiFixPlansRequest {
	r.excludedLowPriority = &excludedLowPriority
	return r
}

// Whether to exclude Outdated Dependencies section (default is false)
func (r ApiFixPlansRequest) ExcludeOutdatedDependencies(excludeOutdatedDependencies bool) ApiFixPlansRequest {
	r.excludeOutdatedDependencies = &excludeOutdatedDependencies
	return r
}

func (r ApiFixPlansRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.FixPlansExecute(r)
}

/*
FixPlans Method for FixPlans

Returns the Remediation Guidance report for a given revision

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator
 @return ApiFixPlansRequest
*/
func (a *RevisionsAPIService) FixPlans(ctx context.Context, locator string) ApiFixPlansRequest {
	return ApiFixPlansRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
//  @return *os.File
func (a *RevisionsAPIService) FixPlansExecute(r ApiFixPlansRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RevisionsAPIService.FixPlans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revisions/{locator}/report/remediation-guidance"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preview", r.preview, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.bundle != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bundle", r.bundle, "form", "")
	}
	if r.excludeQuickWins != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeQuickWins", r.excludeQuickWins, "form", "")
	}
	if r.excludeHighPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeHighPriority", r.excludeHighPriority, "form", "")
	}
	if r.excludedLowPriority != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludedLowPriority", r.excludedLowPriority, "form", "")
	}
	if r.excludeOutdatedDependencies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeOutdatedDependencies", r.excludeOutdatedDependencies, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf", "application/zip", "text/html", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRevisionAttributionEmailRequest struct {
	ctx context.Context
	ApiService *RevisionsAPIService
	locator string
	access *string
	preview *bool
	format *string
	includeDeepDependencies *bool
	includeDirectDependencies *bool
	includeLicenseList *bool
	includeLicenseScan *bool
	includeProjectLicense *bool
	includeCopyrightList *bool
	includeFileMatches *bool
	includeOpenVulnerabilities *bool
	includeClosedVulnerabilities *bool
	includeDependencySummary *bool
	includeLicenseHeaders *bool
	includePackageLabels *bool
	excludePackageLabels *[]string
}

// The public ID
func (r ApiGetRevisionAttributionEmailRequest) Access(access string) ApiGetRevisionAttributionEmailRequest {
	r.access = &access
	return r
}

// Whether to preview the report (default is false)
func (r ApiGetRevisionAttributionEmailRequest) Preview(preview bool) ApiGetRevisionAttributionEmailRequest {
	r.preview = &preview
	return r
}

// The format of the report
func (r ApiGetRevisionAttributionEmailRequest) Format(format string) ApiGetRevisionAttributionEmailRequest {
	r.format = &format
	return r
}

// Whether to include deep dependencies (default is true)
func (r ApiGetRevisionAttributionEmailRequest) IncludeDeepDependencies(includeDeepDependencies bool) ApiGetRevisionAttributionEmailRequest {
	r.includeDeepDependencies = &includeDeepDependencies
	return r
}

// Whether to include direct dependencies (default is true)
func (r ApiGetRevisionAttributionEmailRequest) IncludeDirectDependencies(includeDirectDependencies bool) ApiGetRevisionAttributionEmailRequest {
	r.includeDirectDependencies = &includeDirectDependencies
	return r
}

// Whether to include the license list (default is false)
func (r ApiGetRevisionAttributionEmailRequest) IncludeLicenseList(includeLicenseList bool) ApiGetRevisionAttributionEmailRequest {
	r.includeLicenseList = &includeLicenseList
	return r
}

// Whether to include the license scan (default is false)
func (r ApiGetRevisionAttributionEmailRequest) IncludeLicenseScan(includeLicenseScan bool) ApiGetRevisionAttributionEmailRequest {
	r.includeLicenseScan = &includeLicenseScan
	return r
}

// Whether to include the project license (default is false)
func (r ApiGetRevisionAttributionEmailRequest) IncludeProjectLicense(includeProjectLicense bool) ApiGetRevisionAttributionEmailRequest {
	r.includeProjectLicense = &includeProjectLicense
	return r
}

// Whether to include the copyright list (default is false)
func (r ApiGetRevisionAttributionEmailRequest) IncludeCopyrightList(includeCopyrightList bool) ApiGetRevisionAttributionEmailRequest {
	r.includeCopyrightList = &includeCopyrightList
	return r
}

// Whether to include the file matches (default is false)
func (r ApiGetRevisionAttributionEmailRequest) IncludeFileMatches(includeFileMatches bool) ApiGetRevisionAttributionEmailRequest {
	r.includeFileMatches = &includeFileMatches
	return r
}

// Whether to include the open vulnerabilities (default is false)
func (r ApiGetRevisionAttributionEmailRequest) IncludeOpenVulnerabilities(includeOpenVulnerabilities bool) ApiGetRevisionAttributionEmailRequest {
	r.includeOpenVulnerabilities = &includeOpenVulnerabilities
	return r
}

// Whether to include the closed vulnerabilities (default is false)
func (r ApiGetRevisionAttributionEmailRequest) IncludeClosedVulnerabilities(includeClosedVulnerabilities bool) ApiGetRevisionAttributionEmailRequest {
	r.includeClosedVulnerabilities = &includeClosedVulnerabilities
	return r
}

// Whether to include the dependency summary (default is false)
func (r ApiGetRevisionAttributionEmailRequest) IncludeDependencySummary(includeDependencySummary bool) ApiGetRevisionAttributionEmailRequest {
	r.includeDependencySummary = &includeDependencySummary
	return r
}

// Whether to include the license headers (default is false)
func (r ApiGetRevisionAttributionEmailRequest) IncludeLicenseHeaders(includeLicenseHeaders bool) ApiGetRevisionAttributionEmailRequest {
	r.includeLicenseHeaders = &includeLicenseHeaders
	return r
}

// Whether to include the package labels assigned to each dependency (default is false).
func (r ApiGetRevisionAttributionEmailRequest) IncludePackageLabels(includePackageLabels bool) ApiGetRevisionAttributionEmailRequest {
	r.includePackageLabels = &includePackageLabels
	return r
}

// Exclude dependencies with particular package labels from the report
func (r ApiGetRevisionAttributionEmailRequest) ExcludePackageLabels(excludePackageLabels []string) ApiGetRevisionAttributionEmailRequest {
	r.excludePackageLabels = &excludePackageLabels
	return r
}

func (r ApiGetRevisionAttributionEmailRequest) Execute() (*GetRevisionAttributionEmail200Response, *http.Response, error) {
	return r.ApiService.GetRevisionAttributionEmailExecute(r)
}

/*
GetRevisionAttributionEmail Method for GetRevisionAttributionEmail

Queue a job to generate and send an email of a revision's attribution report

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator the url-encoded locator of the revision
 @return ApiGetRevisionAttributionEmailRequest
*/
func (a *RevisionsAPIService) GetRevisionAttributionEmail(ctx context.Context, locator string) ApiGetRevisionAttributionEmailRequest {
	return ApiGetRevisionAttributionEmailRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
//  @return GetRevisionAttributionEmail200Response
func (a *RevisionsAPIService) GetRevisionAttributionEmailExecute(r ApiGetRevisionAttributionEmailRequest) (*GetRevisionAttributionEmail200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRevisionAttributionEmail200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RevisionsAPIService.GetRevisionAttributionEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revisions/{locator}/attribution/email"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.access != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "access", r.access, "form", "")
	}
	if r.preview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preview", r.preview, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.includeDeepDependencies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDeepDependencies", r.includeDeepDependencies, "form", "")
	}
	if r.includeDirectDependencies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDirectDependencies", r.includeDirectDependencies, "form", "")
	}
	if r.includeLicenseList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLicenseList", r.includeLicenseList, "form", "")
	}
	if r.includeLicenseScan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLicenseScan", r.includeLicenseScan, "form", "")
	}
	if r.includeProjectLicense != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeProjectLicense", r.includeProjectLicense, "form", "")
	}
	if r.includeCopyrightList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCopyrightList", r.includeCopyrightList, "form", "")
	}
	if r.includeFileMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFileMatches", r.includeFileMatches, "form", "")
	}
	if r.includeOpenVulnerabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOpenVulnerabilities", r.includeOpenVulnerabilities, "form", "")
	}
	if r.includeClosedVulnerabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeClosedVulnerabilities", r.includeClosedVulnerabilities, "form", "")
	}
	if r.includeDependencySummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDependencySummary", r.includeDependencySummary, "form", "")
	}
	if r.includeLicenseHeaders != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLicenseHeaders", r.includeLicenseHeaders, "form", "")
	}
	if r.includePackageLabels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePackageLabels", r.includePackageLabels, "form", "")
	}
	if r.excludePackageLabels != nil {
		t := *r.excludePackageLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludePackageLabels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludePackageLabels", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRevisionAttributionJSONRequest struct {
	ctx context.Context
	ApiService *RevisionsAPIService
	locator string
	preview *bool
	includeDeepDependencies *bool
	includeHashAndVersionData *bool
	includeCopyrightList *bool
	includeFileMatches *bool
	includeOpenVulnerabilities *bool
	includeClosedVulnerabilities *bool
	includeNoticeFiles *bool
	includePackageLabels *bool
	excludePackageLabels *[]string
}

// Whether to preview the report (default is false)
func (r ApiGetRevisionAttributionJSONRequest) Preview(preview bool) ApiGetRevisionAttributionJSONRequest {
	r.preview = &preview
	return r
}

// Whether to include deep dependencies (default is true)
func (r ApiGetRevisionAttributionJSONRequest) IncludeDeepDependencies(includeDeepDependencies bool) ApiGetRevisionAttributionJSONRequest {
	r.includeDeepDependencies = &includeDeepDependencies
	return r
}

// Whether to include hash and version data (default is false)
func (r ApiGetRevisionAttributionJSONRequest) IncludeHashAndVersionData(includeHashAndVersionData bool) ApiGetRevisionAttributionJSONRequest {
	r.includeHashAndVersionData = &includeHashAndVersionData
	return r
}

// Whether to include the copyright list (default is false)
func (r ApiGetRevisionAttributionJSONRequest) IncludeCopyrightList(includeCopyrightList bool) ApiGetRevisionAttributionJSONRequest {
	r.includeCopyrightList = &includeCopyrightList
	return r
}

// Whether to include the file matches (default is false)
func (r ApiGetRevisionAttributionJSONRequest) IncludeFileMatches(includeFileMatches bool) ApiGetRevisionAttributionJSONRequest {
	r.includeFileMatches = &includeFileMatches
	return r
}

// Whether to include the open vulnerabilities (default is false)
func (r ApiGetRevisionAttributionJSONRequest) IncludeOpenVulnerabilities(includeOpenVulnerabilities bool) ApiGetRevisionAttributionJSONRequest {
	r.includeOpenVulnerabilities = &includeOpenVulnerabilities
	return r
}

// Whether to include the closed vulnerabilities (default is false)
func (r ApiGetRevisionAttributionJSONRequest) IncludeClosedVulnerabilities(includeClosedVulnerabilities bool) ApiGetRevisionAttributionJSONRequest {
	r.includeClosedVulnerabilities = &includeClosedVulnerabilities
	return r
}

// Whether to include the notice files match data (default is false)
func (r ApiGetRevisionAttributionJSONRequest) IncludeNoticeFiles(includeNoticeFiles bool) ApiGetRevisionAttributionJSONRequest {
	r.includeNoticeFiles = &includeNoticeFiles
	return r
}

// Whether to include the package labels assigned to each dependency (default is false)
func (r ApiGetRevisionAttributionJSONRequest) IncludePackageLabels(includePackageLabels bool) ApiGetRevisionAttributionJSONRequest {
	r.includePackageLabels = &includePackageLabels
	return r
}

// Exclude dependencies with particular package labels from the report
func (r ApiGetRevisionAttributionJSONRequest) ExcludePackageLabels(excludePackageLabels []string) ApiGetRevisionAttributionJSONRequest {
	r.excludePackageLabels = &excludePackageLabels
	return r
}

func (r ApiGetRevisionAttributionJSONRequest) Execute() (*GetRevisionAttributionJSON200Response, *http.Response, error) {
	return r.ApiService.GetRevisionAttributionJSONExecute(r)
}

/*
GetRevisionAttributionJSON Method for GetRevisionAttributionJSON

Return a JSON report of a revision's attribution

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator the url-encoded locator of the revision
 @return ApiGetRevisionAttributionJSONRequest
*/
func (a *RevisionsAPIService) GetRevisionAttributionJSON(ctx context.Context, locator string) ApiGetRevisionAttributionJSONRequest {
	return ApiGetRevisionAttributionJSONRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
//  @return GetRevisionAttributionJSON200Response
func (a *RevisionsAPIService) GetRevisionAttributionJSONExecute(r ApiGetRevisionAttributionJSONRequest) (*GetRevisionAttributionJSON200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRevisionAttributionJSON200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RevisionsAPIService.GetRevisionAttributionJSON")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revisions/{locator}/attribution/json"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.preview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preview", r.preview, "form", "")
	}
	if r.includeDeepDependencies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDeepDependencies", r.includeDeepDependencies, "form", "")
	}
	if r.includeHashAndVersionData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeHashAndVersionData", r.includeHashAndVersionData, "form", "")
	}
	if r.includeCopyrightList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCopyrightList", r.includeCopyrightList, "form", "")
	}
	if r.includeFileMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFileMatches", r.includeFileMatches, "form", "")
	}
	if r.includeOpenVulnerabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOpenVulnerabilities", r.includeOpenVulnerabilities, "form", "")
	}
	if r.includeClosedVulnerabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeClosedVulnerabilities", r.includeClosedVulnerabilities, "form", "")
	}
	if r.includeNoticeFiles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeNoticeFiles", r.includeNoticeFiles, "form", "")
	}
	if r.includePackageLabels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePackageLabels", r.includePackageLabels, "form", "")
	}
	if r.excludePackageLabels != nil {
		t := *r.excludePackageLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludePackageLabels", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludePackageLabels", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNoticeFilesRequest struct {
	ctx context.Context
	ApiService *RevisionsAPIService
	locator string
}

func (r ApiNoticeFilesRequest) Execute() ([]GetRevisionAttributionJSON200ResponseDirectDependenciesInnerNoticeFilesInner, *http.Response, error) {
	return r.ApiService.NoticeFilesExecute(r)
}

/*
NoticeFiles Method for NoticeFiles

Returns all notice files that were found in the distributed source code

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator
 @return ApiNoticeFilesRequest
*/
func (a *RevisionsAPIService) NoticeFiles(ctx context.Context, locator string) ApiNoticeFilesRequest {
	return ApiNoticeFilesRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
//  @return []GetRevisionAttributionJSON200ResponseDirectDependenciesInnerNoticeFilesInner
func (a *RevisionsAPIService) NoticeFilesExecute(r ApiNoticeFilesRequest) ([]GetRevisionAttributionJSON200ResponseDirectDependenciesInnerNoticeFilesInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetRevisionAttributionJSON200ResponseDirectDependenciesInnerNoticeFilesInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RevisionsAPIService.NoticeFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revisions/{locator}/notice-files"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOriginalSbomRequest struct {
	ctx context.Context
	ApiService *RevisionsAPIService
	locator string
}

func (r ApiOriginalSbomRequest) Execute() (*http.Response, error) {
	return r.ApiService.OriginalSbomExecute(r)
}

/*
OriginalSbom Method for OriginalSbom

Fetch the original user-uploaded SBOM for the given locator, whcih must be the locator for an SBOM project.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator
 @return ApiOriginalSbomRequest
*/
func (a *RevisionsAPIService) OriginalSbom(ctx context.Context, locator string) ApiOriginalSbomRequest {
	return ApiOriginalSbomRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
func (a *RevisionsAPIService) OriginalSbomExecute(r ApiOriginalSbomRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RevisionsAPIService.OriginalSbom")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revisions/{locator}/original-sbom"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 302 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateRevisionRequest struct {
	ctx context.Context
	ApiService *RevisionsAPIService
	locator string
	updateRevisionRequest *UpdateRevisionRequest
}

func (r ApiUpdateRevisionRequest) UpdateRevisionRequest(updateRevisionRequest UpdateRevisionRequest) ApiUpdateRevisionRequest {
	r.updateRevisionRequest = &updateRevisionRequest
	return r
}

func (r ApiUpdateRevisionRequest) Execute() (*GetProjectRevisions200ResponseBranchValueInner, *http.Response, error) {
	return r.ApiService.UpdateRevisionExecute(r)
}

/*
UpdateRevision Method for UpdateRevision

Update revision metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator
 @return ApiUpdateRevisionRequest
*/
func (a *RevisionsAPIService) UpdateRevision(ctx context.Context, locator string) ApiUpdateRevisionRequest {
	return ApiUpdateRevisionRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
//  @return GetProjectRevisions200ResponseBranchValueInner
func (a *RevisionsAPIService) UpdateRevisionExecute(r ApiUpdateRevisionRequest) (*GetProjectRevisions200ResponseBranchValueInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProjectRevisions200ResponseBranchValueInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RevisionsAPIService.UpdateRevision")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/revisions/{locator}"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateRevisionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
