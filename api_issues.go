/*
FOSSA API

OpenAPI Specification for public FOSSA APIs

API version: 4.28.61
Contact: support@fossa.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fossa

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"reflect"
)


// IssuesAPIService IssuesAPI service
type IssuesAPIService service

type ApiCreateIssueDisputeRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	issueId int32
	createIssueDisputeRequest *CreateIssueDisputeRequest
}

func (r ApiCreateIssueDisputeRequest) CreateIssueDisputeRequest(createIssueDisputeRequest CreateIssueDisputeRequest) ApiCreateIssueDisputeRequest {
	r.createIssueDisputeRequest = &createIssueDisputeRequest
	return r
}

func (r ApiCreateIssueDisputeRequest) Execute() (*CreateIssueDispute200Response, *http.Response, error) {
	return r.ApiService.CreateIssueDisputeExecute(r)
}

/*
CreateIssueDispute Method for CreateIssueDispute

Creates an issue dispute. For now it only supports licensing issues.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueId ID of the issue that is being disputed.
 @return ApiCreateIssueDisputeRequest
*/
func (a *IssuesAPIService) CreateIssueDispute(ctx context.Context, issueId int32) ApiCreateIssueDisputeRequest {
	return ApiCreateIssueDisputeRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
	}
}

// Execute executes the request
//  @return CreateIssueDispute200Response
func (a *IssuesAPIService) CreateIssueDisputeExecute(r ApiCreateIssueDisputeRequest) (*CreateIssueDispute200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateIssueDispute200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.CreateIssueDispute")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues/{issueId}/disputes"
	localVarPath = strings.Replace(localVarPath, "{"+"issueId"+"}", url.PathEscape(parameterValueToString(r.issueId, "issueId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIssueDisputeRequest == nil {
		return localVarReturnValue, nil, reportError("createIssueDisputeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIssueDisputeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteIssueExceptionRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	id int32
}

func (r ApiDeleteIssueExceptionRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.DeleteIssueExceptionExecute(r)
}

/*
DeleteIssueException Method for DeleteIssueException

Delete an issue ignore rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id ID of the issue exception to be deleted
 @return ApiDeleteIssueExceptionRequest
*/
func (a *IssuesAPIService) DeleteIssueException(ctx context.Context, id int32) ApiDeleteIssueExceptionRequest {
	return ApiDeleteIssueExceptionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return int32
func (a *IssuesAPIService) DeleteIssueExceptionExecute(r ApiDeleteIssueExceptionRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.DeleteIssueException")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues/exceptions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteIssueExceptionsRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	deleteIssueExceptionsRequest *DeleteIssueExceptionsRequest
}

func (r ApiDeleteIssueExceptionsRequest) DeleteIssueExceptionsRequest(deleteIssueExceptionsRequest DeleteIssueExceptionsRequest) ApiDeleteIssueExceptionsRequest {
	r.deleteIssueExceptionsRequest = &deleteIssueExceptionsRequest
	return r
}

func (r ApiDeleteIssueExceptionsRequest) Execute() (*UpdateIssues200Response, *http.Response, error) {
	return r.ApiService.DeleteIssueExceptionsExecute(r)
}

/*
DeleteIssueExceptions Method for DeleteIssueExceptions

Delete issue ignore rules.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteIssueExceptionsRequest
*/
func (a *IssuesAPIService) DeleteIssueExceptions(ctx context.Context) ApiDeleteIssueExceptionsRequest {
	return ApiDeleteIssueExceptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateIssues200Response
func (a *IssuesAPIService) DeleteIssueExceptionsExecute(r ApiDeleteIssueExceptionsRequest) (*UpdateIssues200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateIssues200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.DeleteIssueExceptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues/exceptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteIssueExceptionsRequest == nil {
		return localVarReturnValue, nil, reportError("deleteIssueExceptionsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteIssueExceptionsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteProjectGenerateAttributionSlugRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	locator string
}

func (r ApiDeleteProjectGenerateAttributionSlugRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteProjectGenerateAttributionSlugExecute(r)
}

/*
DeleteProjectGenerateAttributionSlug Method for DeleteProjectGenerateAttributionSlug

Delete a slug used in the URL for the live attribution report for this project

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator
 @return ApiDeleteProjectGenerateAttributionSlugRequest
*/
func (a *IssuesAPIService) DeleteProjectGenerateAttributionSlug(ctx context.Context, locator string) ApiDeleteProjectGenerateAttributionSlugRequest {
	return ApiDeleteProjectGenerateAttributionSlugRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
func (a *IssuesAPIService) DeleteProjectGenerateAttributionSlugExecute(r ApiDeleteProjectGenerateAttributionSlugRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.DeleteProjectGenerateAttributionSlug")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{locator}/generate_attribution_slug"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetGlobalIssuesCSVRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	email *bool
}

// When provided, we will submit the report for background processing and deliver via email when ready. Otherwise the report will be streamed via API
func (r ApiGetGlobalIssuesCSVRequest) Email(email bool) ApiGetGlobalIssuesCSVRequest {
	r.email = &email
	return r
}

func (r ApiGetGlobalIssuesCSVRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetGlobalIssuesCSVExecute(r)
}

/*
GetGlobalIssuesCSV Method for GetGlobalIssuesCSV

Download the global issues report (CSV) or submit for background processing

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGlobalIssuesCSVRequest
*/
func (a *IssuesAPIService) GetGlobalIssuesCSV(ctx context.Context) ApiGetGlobalIssuesCSVRequest {
	return ApiGetGlobalIssuesCSVRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *IssuesAPIService) GetGlobalIssuesCSVExecute(r ApiGetGlobalIssuesCSVRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.GetGlobalIssuesCSV")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues/csv/global"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssueRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	issueId int32
	category *string
	scopeType *string
	scopeId *string
	scopeRevision *string
	scopeRevisionScanId *int32
	scopeRelease *string
	scopeReleaseScanId *string
}

// Issue category
func (r ApiGetIssueRequest) Category(category string) ApiGetIssueRequest {
	r.category = &category
	return r
}

// Scope of issues to view / update
func (r ApiGetIssueRequest) ScopeType(scopeType string) ApiGetIssueRequest {
	r.scopeType = &scopeType
	return r
}

// Project or release group ID (required when scope[type] is \&quot;project\&quot; or \&quot;releaseGroup\&quot;)
func (r ApiGetIssueRequest) ScopeId(scopeId string) ApiGetIssueRequest {
	r.scopeId = &scopeId
	return r
}

// Revision ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssueRequest) ScopeRevision(scopeRevision string) ApiGetIssueRequest {
	r.scopeRevision = &scopeRevision
	return r
}

// Revision scan ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssueRequest) ScopeRevisionScanId(scopeRevisionScanId int32) ApiGetIssueRequest {
	r.scopeRevisionScanId = &scopeRevisionScanId
	return r
}

// Release group ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssueRequest) ScopeRelease(scopeRelease string) ApiGetIssueRequest {
	r.scopeRelease = &scopeRelease
	return r
}

// Release scan ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssueRequest) ScopeReleaseScanId(scopeReleaseScanId string) ApiGetIssueRequest {
	r.scopeReleaseScanId = &scopeReleaseScanId
	return r
}

func (r ApiGetIssueRequest) Execute() (*GetIssue200Response, *http.Response, error) {
	return r.ApiService.GetIssueExecute(r)
}

/*
GetIssue Method for GetIssue

Retrieve a single issue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueId Issue ID
 @return ApiGetIssueRequest
*/
func (a *IssuesAPIService) GetIssue(ctx context.Context, issueId int32) ApiGetIssueRequest {
	return ApiGetIssueRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
	}
}

// Execute executes the request
//  @return GetIssue200Response
func (a *IssuesAPIService) GetIssueExecute(r ApiGetIssueRequest) (*GetIssue200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIssue200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.GetIssue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues/{issueId}"
	localVarPath = strings.Replace(localVarPath, "{"+"issueId"+"}", url.PathEscape(parameterValueToString(r.issueId, "issueId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.category == nil {
		return localVarReturnValue, nil, reportError("category is required and must be specified")
	}
	if r.scopeType == nil {
		return localVarReturnValue, nil, reportError("scopeType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "scope[type]", r.scopeType, "form", "")
	if r.scopeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[id]", r.scopeId, "form", "")
	}
	if r.scopeRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revision]", r.scopeRevision, "form", "")
	}
	if r.scopeRevisionScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revisionScanId]", r.scopeRevisionScanId, "form", "")
	}
	if r.scopeRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[release]", r.scopeRelease, "form", "")
	}
	if r.scopeReleaseScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[releaseScanId]", r.scopeReleaseScanId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssueAffectedProjectsRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	issueId int32
	category *string
	scopeType *string
	scopeId *string
	scopeRevision *string
	scopeRevisionScanId *int32
	scopeRelease *string
	scopeReleaseScanId *string
}

// Issue category
func (r ApiGetIssueAffectedProjectsRequest) Category(category string) ApiGetIssueAffectedProjectsRequest {
	r.category = &category
	return r
}

// Scope of issues to view / update
func (r ApiGetIssueAffectedProjectsRequest) ScopeType(scopeType string) ApiGetIssueAffectedProjectsRequest {
	r.scopeType = &scopeType
	return r
}

// Project or release group ID (required when scope[type] is \&quot;project\&quot; or \&quot;releaseGroup\&quot;)
func (r ApiGetIssueAffectedProjectsRequest) ScopeId(scopeId string) ApiGetIssueAffectedProjectsRequest {
	r.scopeId = &scopeId
	return r
}

// Revision ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssueAffectedProjectsRequest) ScopeRevision(scopeRevision string) ApiGetIssueAffectedProjectsRequest {
	r.scopeRevision = &scopeRevision
	return r
}

// Revision scan ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssueAffectedProjectsRequest) ScopeRevisionScanId(scopeRevisionScanId int32) ApiGetIssueAffectedProjectsRequest {
	r.scopeRevisionScanId = &scopeRevisionScanId
	return r
}

// Release group ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssueAffectedProjectsRequest) ScopeRelease(scopeRelease string) ApiGetIssueAffectedProjectsRequest {
	r.scopeRelease = &scopeRelease
	return r
}

// Release scan ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssueAffectedProjectsRequest) ScopeReleaseScanId(scopeReleaseScanId string) ApiGetIssueAffectedProjectsRequest {
	r.scopeReleaseScanId = &scopeReleaseScanId
	return r
}

func (r ApiGetIssueAffectedProjectsRequest) Execute() ([]GetIssueAffectedProjects200ResponseInner, *http.Response, error) {
	return r.ApiService.GetIssueAffectedProjectsExecute(r)
}

/*
GetIssueAffectedProjects Method for GetIssueAffectedProjects

Retrieves a list of affected projects for a given issue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param issueId Issue ID
 @return ApiGetIssueAffectedProjectsRequest
*/
func (a *IssuesAPIService) GetIssueAffectedProjects(ctx context.Context, issueId int32) ApiGetIssueAffectedProjectsRequest {
	return ApiGetIssueAffectedProjectsRequest{
		ApiService: a,
		ctx: ctx,
		issueId: issueId,
	}
}

// Execute executes the request
//  @return []GetIssueAffectedProjects200ResponseInner
func (a *IssuesAPIService) GetIssueAffectedProjectsExecute(r ApiGetIssueAffectedProjectsRequest) ([]GetIssueAffectedProjects200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetIssueAffectedProjects200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.GetIssueAffectedProjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues/{issueId}/affected-projects"
	localVarPath = strings.Replace(localVarPath, "{"+"issueId"+"}", url.PathEscape(parameterValueToString(r.issueId, "issueId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.category == nil {
		return localVarReturnValue, nil, reportError("category is required and must be specified")
	}
	if r.scopeType == nil {
		return localVarReturnValue, nil, reportError("scopeType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "scope[type]", r.scopeType, "form", "")
	if r.scopeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[id]", r.scopeId, "form", "")
	}
	if r.scopeRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revision]", r.scopeRevision, "form", "")
	}
	if r.scopeRevisionScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revisionScanId]", r.scopeRevisionScanId, "form", "")
	}
	if r.scopeRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[release]", r.scopeRelease, "form", "")
	}
	if r.scopeReleaseScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[releaseScanId]", r.scopeReleaseScanId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssueCWEsRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	scopeType *string
	status *string
	scopeId *string
	scopeRevision *string
	scopeRevisionScanId *int32
	scopeRelease *string
	scopeReleaseScanId *string
	scopeCompareToRevision *string
	scopeCompareToChangeStatus *string
	teamId *[]GetIssueCWEsTeamIdParameterInner
}

// Scope of issues to view / update
func (r ApiGetIssueCWEsRequest) ScopeType(scopeType string) ApiGetIssueCWEsRequest {
	r.scopeType = &scopeType
	return r
}

// Issue status
func (r ApiGetIssueCWEsRequest) Status(status string) ApiGetIssueCWEsRequest {
	r.status = &status
	return r
}

// Project or release group ID (required when scope[type] is \&quot;project\&quot; or \&quot;releaseGroup\&quot;)
func (r ApiGetIssueCWEsRequest) ScopeId(scopeId string) ApiGetIssueCWEsRequest {
	r.scopeId = &scopeId
	return r
}

// Revision ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssueCWEsRequest) ScopeRevision(scopeRevision string) ApiGetIssueCWEsRequest {
	r.scopeRevision = &scopeRevision
	return r
}

// Revision scan ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssueCWEsRequest) ScopeRevisionScanId(scopeRevisionScanId int32) ApiGetIssueCWEsRequest {
	r.scopeRevisionScanId = &scopeRevisionScanId
	return r
}

// Release group ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssueCWEsRequest) ScopeRelease(scopeRelease string) ApiGetIssueCWEsRequest {
	r.scopeRelease = &scopeRelease
	return r
}

// Release scan ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssueCWEsRequest) ScopeReleaseScanId(scopeReleaseScanId string) ApiGetIssueCWEsRequest {
	r.scopeReleaseScanId = &scopeReleaseScanId
	return r
}

// The revision ID to compare issues with. Only availabe for Project Scope.
func (r ApiGetIssueCWEsRequest) ScopeCompareToRevision(scopeCompareToRevision string) ApiGetIssueCWEsRequest {
	r.scopeCompareToRevision = &scopeCompareToRevision
	return r
}

// The status of issues to fetch when comparing issues. - New issues are present in the current revision but not in the comparison revision. - Remediated issues are present in the comparison revision but not in the current revision. - Unchanged issues are present in both revisions. Only available for Project Scope. 
func (r ApiGetIssueCWEsRequest) ScopeCompareToChangeStatus(scopeCompareToChangeStatus string) ApiGetIssueCWEsRequest {
	r.scopeCompareToChangeStatus = &scopeCompareToChangeStatus
	return r
}

// Filter by one or more team IDs. Providing \&quot;null\&quot; will return all unassigned projects.
func (r ApiGetIssueCWEsRequest) TeamId(teamId []GetIssueCWEsTeamIdParameterInner) ApiGetIssueCWEsRequest {
	r.teamId = &teamId
	return r
}

func (r ApiGetIssueCWEsRequest) Execute() (*GetIssueCWEs200Response, *http.Response, error) {
	return r.ApiService.GetIssueCWEsExecute(r)
}

/*
GetIssueCWEs Method for GetIssueCWEs

Get the set of unique CWEs associated with current issues

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIssueCWEsRequest
*/
func (a *IssuesAPIService) GetIssueCWEs(ctx context.Context) ApiGetIssueCWEsRequest {
	return ApiGetIssueCWEsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetIssueCWEs200Response
func (a *IssuesAPIService) GetIssueCWEsExecute(r ApiGetIssueCWEsRequest) (*GetIssueCWEs200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIssueCWEs200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.GetIssueCWEs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues/cwes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.scopeType == nil {
		return localVarReturnValue, nil, reportError("scopeType is required and must be specified")
	}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "scope[type]", r.scopeType, "form", "")
	if r.scopeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[id]", r.scopeId, "form", "")
	}
	if r.scopeRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revision]", r.scopeRevision, "form", "")
	}
	if r.scopeRevisionScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revisionScanId]", r.scopeRevisionScanId, "form", "")
	}
	if r.scopeRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[release]", r.scopeRelease, "form", "")
	}
	if r.scopeReleaseScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[releaseScanId]", r.scopeReleaseScanId, "form", "")
	}
	if r.scopeCompareToRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[compareTo][revision]", r.scopeCompareToRevision, "form", "")
	}
	if r.scopeCompareToChangeStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[compareTo][changeStatus]", r.scopeCompareToChangeStatus, "form", "")
	}
	if r.teamId != nil {
		t := *r.teamId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "teamId[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "teamId[]", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssueDiffComparisonSummariesRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	category *string
	scopeType *string
	scopeId *string
	scopeRevision *string
	scopeRevisionScanId *int32
	scopeCompareToRevision *string
	scopeCompareToChangeStatus *string
	ids *[]int32
	filterRevisionIds *[]string
	filterSearch *string
	filterDepths *[]string
	filterTicketed *[]string
	filterContainerLayers *[]string
	filterType *GetIssueStatusesFilterTypeParameter
	filterPackageManagers *[]string
	filterCwes *[]string
	filterProjectLabels *[]string
	filterIdentification *[]string
	filterSeverity *[]string
	filterFoundAfter *string
	filterHasFix *[]string
	filterUpgradeDistance *[]string
	filterExploitMaturity *[]string
	filterIgnoreReason *[]string
	filterEpss *GetIssueDiffComparisonSummariesFilterEpssParameter
	filterConfidence *[]string
}

// Issue category
func (r ApiGetIssueDiffComparisonSummariesRequest) Category(category string) ApiGetIssueDiffComparisonSummariesRequest {
	r.category = &category
	return r
}

// Scope of issues to view
func (r ApiGetIssueDiffComparisonSummariesRequest) ScopeType(scopeType string) ApiGetIssueDiffComparisonSummariesRequest {
	r.scopeType = &scopeType
	return r
}

// Project or release group ID (required when scope[type] is \&quot;project\&quot; or \&quot;releaseGroup\&quot;)
func (r ApiGetIssueDiffComparisonSummariesRequest) ScopeId(scopeId string) ApiGetIssueDiffComparisonSummariesRequest {
	r.scopeId = &scopeId
	return r
}

// Revision ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssueDiffComparisonSummariesRequest) ScopeRevision(scopeRevision string) ApiGetIssueDiffComparisonSummariesRequest {
	r.scopeRevision = &scopeRevision
	return r
}

// Revision scan ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssueDiffComparisonSummariesRequest) ScopeRevisionScanId(scopeRevisionScanId int32) ApiGetIssueDiffComparisonSummariesRequest {
	r.scopeRevisionScanId = &scopeRevisionScanId
	return r
}

// The revision ID to compare issues with. Only availabe for Project Scope.
func (r ApiGetIssueDiffComparisonSummariesRequest) ScopeCompareToRevision(scopeCompareToRevision string) ApiGetIssueDiffComparisonSummariesRequest {
	r.scopeCompareToRevision = &scopeCompareToRevision
	return r
}

// The status of issues to fetch when comparing issues. - New issues are present in the current revision but not in the comparison revision. - Remediated issues are present in the comparison revision but not in the current revision. - Unchanged issues are present in both revisions. Only available for Project Scope. 
func (r ApiGetIssueDiffComparisonSummariesRequest) ScopeCompareToChangeStatus(scopeCompareToChangeStatus string) ApiGetIssueDiffComparisonSummariesRequest {
	r.scopeCompareToChangeStatus = &scopeCompareToChangeStatus
	return r
}

// Filter by specific issue IDs
func (r ApiGetIssueDiffComparisonSummariesRequest) Ids(ids []int32) ApiGetIssueDiffComparisonSummariesRequest {
	r.ids = &ids
	return r
}

// Filter by specific revision IDs
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterRevisionIds(filterRevisionIds []string) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterRevisionIds = &filterRevisionIds
	return r
}

// Filter by package name or CVE (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterSearch(filterSearch string) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterSearch = &filterSearch
	return r
}

// Filter by issue depth
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterDepths(filterDepths []string) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterDepths = &filterDepths
	return r
}

// Filter by ticketed status.  Only available to premium users.
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterTicketed(filterTicketed []string) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterTicketed = &filterTicketed
	return r
}

// Filter by container layer
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterContainerLayers(filterContainerLayers []string) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterContainerLayers = &filterContainerLayers
	return r
}

// Filter by licensing issue type (when category is \&quot;licensing\&quot;) or quality issue type (when category is \&quot;quality\&quot;) 
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterType(filterType GetIssueStatusesFilterTypeParameter) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterType = &filterType
	return r
}

// Filter by specific package managers
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterPackageManagers(filterPackageManagers []string) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterPackageManagers = &filterPackageManagers
	return r
}

// Filter by specific CWE identifiers
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterCwes(filterCwes []string) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterCwes = &filterCwes
	return r
}

// Filter by specific project labels
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterProjectLabels(filterProjectLabels []string) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterProjectLabels = &filterProjectLabels
	return r
}

// Filter by license identification (when category is \&quot;licensing\&quot;)
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterIdentification(filterIdentification []string) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterIdentification = &filterIdentification
	return r
}

// Filter by vuln severity (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterSeverity(filterSeverity []string) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterSeverity = &filterSeverity
	return r
}

// Include only issues found on after a given date.  Only available to premium users
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterFoundAfter(filterFoundAfter string) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterFoundAfter = &filterFoundAfter
	return r
}

// Filter by vuln fixability (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterHasFix(filterHasFix []string) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterHasFix = &filterHasFix
	return r
}

// Filter by vuln upgrade distance (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterUpgradeDistance(filterUpgradeDistance []string) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterUpgradeDistance = &filterUpgradeDistance
	return r
}

// Filter by vuln exploit maturity (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterExploitMaturity(filterExploitMaturity []string) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterExploitMaturity = &filterExploitMaturity
	return r
}

// Filter by vuln ignore reason (when category is \&quot;vulnerability\&quot;) This value appears in the vulnerabilities.analysis.detail field in CycloneDX SBOM reports 
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterIgnoreReason(filterIgnoreReason []string) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterIgnoreReason = &filterIgnoreReason
	return r
}

// Filter by epss &#39;score&#39; or &#39;percentile&#39;. All fields are required.  Only available to premium users.
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterEpss(filterEpss GetIssueDiffComparisonSummariesFilterEpssParameter) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterEpss = &filterEpss
	return r
}

// Filter issues by their binary dependency confidence level(s)
func (r ApiGetIssueDiffComparisonSummariesRequest) FilterConfidence(filterConfidence []string) ApiGetIssueDiffComparisonSummariesRequest {
	r.filterConfidence = &filterConfidence
	return r
}

func (r ApiGetIssueDiffComparisonSummariesRequest) Execute() (*GetIssueDiffComparisonSummaries200Response, *http.Response, error) {
	return r.ApiService.GetIssueDiffComparisonSummariesExecute(r)
}

/*
GetIssueDiffComparisonSummaries Method for GetIssueDiffComparisonSummaries

Retrieve the counts for the different change statuses when in Issue Comparison mode. Only available for Project Scope.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIssueDiffComparisonSummariesRequest
*/
func (a *IssuesAPIService) GetIssueDiffComparisonSummaries(ctx context.Context) ApiGetIssueDiffComparisonSummariesRequest {
	return ApiGetIssueDiffComparisonSummariesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetIssueDiffComparisonSummaries200Response
func (a *IssuesAPIService) GetIssueDiffComparisonSummariesExecute(r ApiGetIssueDiffComparisonSummariesRequest) (*GetIssueDiffComparisonSummaries200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIssueDiffComparisonSummaries200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.GetIssueDiffComparisonSummaries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues/compare/summaries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.category == nil {
		return localVarReturnValue, nil, reportError("category is required and must be specified")
	}
	if r.scopeType == nil {
		return localVarReturnValue, nil, reportError("scopeType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "scope[type]", r.scopeType, "form", "")
	if r.scopeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[id]", r.scopeId, "form", "")
	}
	if r.scopeRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revision]", r.scopeRevision, "form", "")
	}
	if r.scopeRevisionScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revisionScanId]", r.scopeRevisionScanId, "form", "")
	}
	if r.scopeCompareToRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[compareTo][revision]", r.scopeCompareToRevision, "form", "")
	}
	if r.scopeCompareToChangeStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[compareTo][changeStatus]", r.scopeCompareToChangeStatus, "form", "")
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids[]", t, "form", "multi")
		}
	}
	if r.filterRevisionIds != nil {
		t := *r.filterRevisionIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[revisionIds][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[revisionIds][]", t, "form", "multi")
		}
	}
	if r.filterSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[search]", r.filterSearch, "form", "")
	}
	if r.filterDepths != nil {
		t := *r.filterDepths
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[depths][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[depths][]", t, "form", "multi")
		}
	}
	if r.filterTicketed != nil {
		t := *r.filterTicketed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ticketed][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ticketed][]", t, "form", "multi")
		}
	}
	if r.filterContainerLayers != nil {
		t := *r.filterContainerLayers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[containerLayers][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[containerLayers][]", t, "form", "multi")
		}
	}
	if r.filterType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[type][]", r.filterType, "form", "")
	}
	if r.filterPackageManagers != nil {
		t := *r.filterPackageManagers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[packageManagers][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[packageManagers][]", t, "form", "multi")
		}
	}
	if r.filterCwes != nil {
		t := *r.filterCwes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[cwes][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[cwes][]", t, "form", "multi")
		}
	}
	if r.filterProjectLabels != nil {
		t := *r.filterProjectLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[projectLabels][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[projectLabels][]", t, "form", "multi")
		}
	}
	if r.filterIdentification != nil {
		t := *r.filterIdentification
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[identification][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[identification][]", t, "form", "multi")
		}
	}
	if r.filterSeverity != nil {
		t := *r.filterSeverity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[severity][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[severity][]", t, "form", "multi")
		}
	}
	if r.filterFoundAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[foundAfter]", r.filterFoundAfter, "form", "")
	}
	if r.filterHasFix != nil {
		t := *r.filterHasFix
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[hasFix][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[hasFix][]", t, "form", "multi")
		}
	}
	if r.filterUpgradeDistance != nil {
		t := *r.filterUpgradeDistance
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[upgradeDistance][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[upgradeDistance][]", t, "form", "multi")
		}
	}
	if r.filterExploitMaturity != nil {
		t := *r.filterExploitMaturity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[exploitMaturity][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[exploitMaturity][]", t, "form", "multi")
		}
	}
	if r.filterIgnoreReason != nil {
		t := *r.filterIgnoreReason
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ignoreReason][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ignoreReason][]", t, "form", "multi")
		}
	}
	if r.filterEpss != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[epss]", r.filterEpss, "deepObject", "")
	}
	if r.filterConfidence != nil {
		t := *r.filterConfidence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[confidence][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[confidence][]", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssueExceptionsRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	filtersCategory *string
	filtersProjectId *string
	filtersReleaseGroupId *int32
	search *string
	sortBy *string
	orderBy *string
	page *int32
	count *int32
}

// Exception category
func (r ApiGetIssueExceptionsRequest) FiltersCategory(filtersCategory string) ApiGetIssueExceptionsRequest {
	r.filtersCategory = &filtersCategory
	return r
}

// Exception project ID
func (r ApiGetIssueExceptionsRequest) FiltersProjectId(filtersProjectId string) ApiGetIssueExceptionsRequest {
	r.filtersProjectId = &filtersProjectId
	return r
}

// Exception release group ID
func (r ApiGetIssueExceptionsRequest) FiltersReleaseGroupId(filtersReleaseGroupId int32) ApiGetIssueExceptionsRequest {
	r.filtersReleaseGroupId = &filtersReleaseGroupId
	return r
}

// Search term (search by created by, revision, note, or package)
func (r ApiGetIssueExceptionsRequest) Search(search string) ApiGetIssueExceptionsRequest {
	r.search = &search
	return r
}

// Sort by field (id, package, created by, and ignore scope)
func (r ApiGetIssueExceptionsRequest) SortBy(sortBy string) ApiGetIssueExceptionsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort order
func (r ApiGetIssueExceptionsRequest) OrderBy(orderBy string) ApiGetIssueExceptionsRequest {
	r.orderBy = &orderBy
	return r
}

// The specific page of data to return
func (r ApiGetIssueExceptionsRequest) Page(page int32) ApiGetIssueExceptionsRequest {
	r.page = &page
	return r
}

// The number of items to return in each page of results
func (r ApiGetIssueExceptionsRequest) Count(count int32) ApiGetIssueExceptionsRequest {
	r.count = &count
	return r
}

func (r ApiGetIssueExceptionsRequest) Execute() (*GetIssueExceptions200Response, *http.Response, error) {
	return r.ApiService.GetIssueExceptionsExecute(r)
}

/*
GetIssueExceptions Method for GetIssueExceptions

List issue ignore rules.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIssueExceptionsRequest
*/
func (a *IssuesAPIService) GetIssueExceptions(ctx context.Context) ApiGetIssueExceptionsRequest {
	return ApiGetIssueExceptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetIssueExceptions200Response
func (a *IssuesAPIService) GetIssueExceptionsExecute(r ApiGetIssueExceptionsRequest) (*GetIssueExceptions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIssueExceptions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.GetIssueExceptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues/exceptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filtersCategory == nil {
		return localVarReturnValue, nil, reportError("filtersCategory is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "filters[category]", r.filtersCategory, "form", "")
	if r.filtersProjectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters[projectId]", r.filtersProjectId, "form", "")
	}
	if r.filtersReleaseGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filters[releaseGroupId]", r.filtersReleaseGroupId, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 20
		r.count = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssuePackageManagersRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	category *string
	scopeType *string
	status *string
	scopeId *string
	scopeRevision *string
	scopeRevisionScanId *int32
	scopeRelease *string
	scopeReleaseScanId *string
}

// Issue category
func (r ApiGetIssuePackageManagersRequest) Category(category string) ApiGetIssuePackageManagersRequest {
	r.category = &category
	return r
}

// Scope of issues to view / update
func (r ApiGetIssuePackageManagersRequest) ScopeType(scopeType string) ApiGetIssuePackageManagersRequest {
	r.scopeType = &scopeType
	return r
}

// Issue status
func (r ApiGetIssuePackageManagersRequest) Status(status string) ApiGetIssuePackageManagersRequest {
	r.status = &status
	return r
}

// Project or release group ID (required when scope[type] is \&quot;project\&quot; or \&quot;releaseGroup\&quot;)
func (r ApiGetIssuePackageManagersRequest) ScopeId(scopeId string) ApiGetIssuePackageManagersRequest {
	r.scopeId = &scopeId
	return r
}

// Revision ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssuePackageManagersRequest) ScopeRevision(scopeRevision string) ApiGetIssuePackageManagersRequest {
	r.scopeRevision = &scopeRevision
	return r
}

// Revision scan ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssuePackageManagersRequest) ScopeRevisionScanId(scopeRevisionScanId int32) ApiGetIssuePackageManagersRequest {
	r.scopeRevisionScanId = &scopeRevisionScanId
	return r
}

// Release group ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssuePackageManagersRequest) ScopeRelease(scopeRelease string) ApiGetIssuePackageManagersRequest {
	r.scopeRelease = &scopeRelease
	return r
}

// Release scan ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssuePackageManagersRequest) ScopeReleaseScanId(scopeReleaseScanId string) ApiGetIssuePackageManagersRequest {
	r.scopeReleaseScanId = &scopeReleaseScanId
	return r
}

func (r ApiGetIssuePackageManagersRequest) Execute() (*GetIssuePackageManagers200Response, *http.Response, error) {
	return r.ApiService.GetIssuePackageManagersExecute(r)
}

/*
GetIssuePackageManagers Method for GetIssuePackageManagers

Get the set of unique package managers associated with current issues

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIssuePackageManagersRequest
*/
func (a *IssuesAPIService) GetIssuePackageManagers(ctx context.Context) ApiGetIssuePackageManagersRequest {
	return ApiGetIssuePackageManagersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetIssuePackageManagers200Response
func (a *IssuesAPIService) GetIssuePackageManagersExecute(r ApiGetIssuePackageManagersRequest) (*GetIssuePackageManagers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIssuePackageManagers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.GetIssuePackageManagers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues/package-managers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.category == nil {
		return localVarReturnValue, nil, reportError("category is required and must be specified")
	}
	if r.scopeType == nil {
		return localVarReturnValue, nil, reportError("scopeType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "form", "")
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "scope[type]", r.scopeType, "form", "")
	if r.scopeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[id]", r.scopeId, "form", "")
	}
	if r.scopeRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revision]", r.scopeRevision, "form", "")
	}
	if r.scopeRevisionScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revisionScanId]", r.scopeRevisionScanId, "form", "")
	}
	if r.scopeRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[release]", r.scopeRelease, "form", "")
	}
	if r.scopeReleaseScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[releaseScanId]", r.scopeReleaseScanId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssueStatusesRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	category *string
	scopeType *string
	scopeId *string
	scopeRevision *string
	scopeRevisionScanId *int32
	scopeRelease *string
	scopeReleaseScanId *string
	scopeCompareToRevision *string
	scopeCompareToChangeStatus *string
	ids *[]int32
	filterRevisionIds *[]string
	filterSearch *string
	filterDepths *[]string
	filterTicketed *[]string
	filterContainerLayers *[]string
	filterType *GetIssueStatusesFilterTypeParameter
	filterPackageManagers *[]string
	filterProjectLabels *[]string
	filterIdentification *[]string
	filterSeverity *[]string
	filterFoundAfter *string
	filterHasFix *[]string
	filterUpgradeDistance *[]string
	filterExploitMaturity *[]string
	filterIgnoreReason *[]string
	filterLicenses *[]string
}

// Issue category
func (r ApiGetIssueStatusesRequest) Category(category string) ApiGetIssueStatusesRequest {
	r.category = &category
	return r
}

// Scope of issues to view / update
func (r ApiGetIssueStatusesRequest) ScopeType(scopeType string) ApiGetIssueStatusesRequest {
	r.scopeType = &scopeType
	return r
}

// Project or release group ID (required when scope[type] is \&quot;project\&quot; or \&quot;releaseGroup\&quot;)
func (r ApiGetIssueStatusesRequest) ScopeId(scopeId string) ApiGetIssueStatusesRequest {
	r.scopeId = &scopeId
	return r
}

// Revision ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssueStatusesRequest) ScopeRevision(scopeRevision string) ApiGetIssueStatusesRequest {
	r.scopeRevision = &scopeRevision
	return r
}

// Revision scan ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssueStatusesRequest) ScopeRevisionScanId(scopeRevisionScanId int32) ApiGetIssueStatusesRequest {
	r.scopeRevisionScanId = &scopeRevisionScanId
	return r
}

// Release group ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssueStatusesRequest) ScopeRelease(scopeRelease string) ApiGetIssueStatusesRequest {
	r.scopeRelease = &scopeRelease
	return r
}

// Release scan ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssueStatusesRequest) ScopeReleaseScanId(scopeReleaseScanId string) ApiGetIssueStatusesRequest {
	r.scopeReleaseScanId = &scopeReleaseScanId
	return r
}

// The revision ID to compare issues with. Only availabe for Project Scope.
func (r ApiGetIssueStatusesRequest) ScopeCompareToRevision(scopeCompareToRevision string) ApiGetIssueStatusesRequest {
	r.scopeCompareToRevision = &scopeCompareToRevision
	return r
}

// The status of issues to fetch when comparing issues. - New issues are present in the current revision but not in the comparison revision. - Remediated issues are present in the comparison revision but not in the current revision. - Unchanged issues are present in both revisions. Only available for Project Scope. 
func (r ApiGetIssueStatusesRequest) ScopeCompareToChangeStatus(scopeCompareToChangeStatus string) ApiGetIssueStatusesRequest {
	r.scopeCompareToChangeStatus = &scopeCompareToChangeStatus
	return r
}

// Filter by specific issue IDs
func (r ApiGetIssueStatusesRequest) Ids(ids []int32) ApiGetIssueStatusesRequest {
	r.ids = &ids
	return r
}

// Filter by specific revision IDs
func (r ApiGetIssueStatusesRequest) FilterRevisionIds(filterRevisionIds []string) ApiGetIssueStatusesRequest {
	r.filterRevisionIds = &filterRevisionIds
	return r
}

// Filter by package name or CVE (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssueStatusesRequest) FilterSearch(filterSearch string) ApiGetIssueStatusesRequest {
	r.filterSearch = &filterSearch
	return r
}

// Filter by issue depth
func (r ApiGetIssueStatusesRequest) FilterDepths(filterDepths []string) ApiGetIssueStatusesRequest {
	r.filterDepths = &filterDepths
	return r
}

// Filter by ticketed status.  Only available to premium users.
func (r ApiGetIssueStatusesRequest) FilterTicketed(filterTicketed []string) ApiGetIssueStatusesRequest {
	r.filterTicketed = &filterTicketed
	return r
}

// Filter by container layer
func (r ApiGetIssueStatusesRequest) FilterContainerLayers(filterContainerLayers []string) ApiGetIssueStatusesRequest {
	r.filterContainerLayers = &filterContainerLayers
	return r
}

// Filter by licensing issue type (when category is \&quot;licensing\&quot;) or quality issue type (when category is \&quot;quality\&quot;) 
func (r ApiGetIssueStatusesRequest) FilterType(filterType GetIssueStatusesFilterTypeParameter) ApiGetIssueStatusesRequest {
	r.filterType = &filterType
	return r
}

// Filter by specific package managers
func (r ApiGetIssueStatusesRequest) FilterPackageManagers(filterPackageManagers []string) ApiGetIssueStatusesRequest {
	r.filterPackageManagers = &filterPackageManagers
	return r
}

// Filter by specific project labels
func (r ApiGetIssueStatusesRequest) FilterProjectLabels(filterProjectLabels []string) ApiGetIssueStatusesRequest {
	r.filterProjectLabels = &filterProjectLabels
	return r
}

// Filter by license identification (when category is \&quot;licensing\&quot;)
func (r ApiGetIssueStatusesRequest) FilterIdentification(filterIdentification []string) ApiGetIssueStatusesRequest {
	r.filterIdentification = &filterIdentification
	return r
}

// Filter by vuln severity (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssueStatusesRequest) FilterSeverity(filterSeverity []string) ApiGetIssueStatusesRequest {
	r.filterSeverity = &filterSeverity
	return r
}

// Include only issues found on after a given date.  Only available to premium users
func (r ApiGetIssueStatusesRequest) FilterFoundAfter(filterFoundAfter string) ApiGetIssueStatusesRequest {
	r.filterFoundAfter = &filterFoundAfter
	return r
}

// Filter by vuln fixability (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssueStatusesRequest) FilterHasFix(filterHasFix []string) ApiGetIssueStatusesRequest {
	r.filterHasFix = &filterHasFix
	return r
}

// Filter by vuln upgrade distance (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssueStatusesRequest) FilterUpgradeDistance(filterUpgradeDistance []string) ApiGetIssueStatusesRequest {
	r.filterUpgradeDistance = &filterUpgradeDistance
	return r
}

// Filter by vuln exploit maturity (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssueStatusesRequest) FilterExploitMaturity(filterExploitMaturity []string) ApiGetIssueStatusesRequest {
	r.filterExploitMaturity = &filterExploitMaturity
	return r
}

// Filter by vuln ignore reason (when category is \&quot;vulnerability\&quot;) This value appears in the vulnerabilities.analysis.detail field in CycloneDX SBOM reports 
func (r ApiGetIssueStatusesRequest) FilterIgnoreReason(filterIgnoreReason []string) ApiGetIssueStatusesRequest {
	r.filterIgnoreReason = &filterIgnoreReason
	return r
}

// Filter by issues affected by a set of license ID&#39;s (when category is \&quot;licensing\&quot;)
func (r ApiGetIssueStatusesRequest) FilterLicenses(filterLicenses []string) ApiGetIssueStatusesRequest {
	r.filterLicenses = &filterLicenses
	return r
}

func (r ApiGetIssueStatusesRequest) Execute() (*GetIssueStatuses200Response, *http.Response, error) {
	return r.ApiService.GetIssueStatusesExecute(r)
}

/*
GetIssueStatuses Method for GetIssueStatuses

Get a count of issues by status, matching the provided filters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIssueStatusesRequest
*/
func (a *IssuesAPIService) GetIssueStatuses(ctx context.Context) ApiGetIssueStatusesRequest {
	return ApiGetIssueStatusesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetIssueStatuses200Response
func (a *IssuesAPIService) GetIssueStatusesExecute(r ApiGetIssueStatusesRequest) (*GetIssueStatuses200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIssueStatuses200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.GetIssueStatuses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues/statuses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.category == nil {
		return localVarReturnValue, nil, reportError("category is required and must be specified")
	}
	if r.scopeType == nil {
		return localVarReturnValue, nil, reportError("scopeType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "scope[type]", r.scopeType, "form", "")
	if r.scopeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[id]", r.scopeId, "form", "")
	}
	if r.scopeRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revision]", r.scopeRevision, "form", "")
	}
	if r.scopeRevisionScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revisionScanId]", r.scopeRevisionScanId, "form", "")
	}
	if r.scopeRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[release]", r.scopeRelease, "form", "")
	}
	if r.scopeReleaseScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[releaseScanId]", r.scopeReleaseScanId, "form", "")
	}
	if r.scopeCompareToRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[compareTo][revision]", r.scopeCompareToRevision, "form", "")
	}
	if r.scopeCompareToChangeStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[compareTo][changeStatus]", r.scopeCompareToChangeStatus, "form", "")
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids[]", t, "form", "multi")
		}
	}
	if r.filterRevisionIds != nil {
		t := *r.filterRevisionIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[revisionIds][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[revisionIds][]", t, "form", "multi")
		}
	}
	if r.filterSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[search]", r.filterSearch, "form", "")
	}
	if r.filterDepths != nil {
		t := *r.filterDepths
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[depths][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[depths][]", t, "form", "multi")
		}
	}
	if r.filterTicketed != nil {
		t := *r.filterTicketed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ticketed][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ticketed][]", t, "form", "multi")
		}
	}
	if r.filterContainerLayers != nil {
		t := *r.filterContainerLayers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[containerLayers][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[containerLayers][]", t, "form", "multi")
		}
	}
	if r.filterType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[type][]", r.filterType, "form", "")
	}
	if r.filterPackageManagers != nil {
		t := *r.filterPackageManagers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[packageManagers][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[packageManagers][]", t, "form", "multi")
		}
	}
	if r.filterProjectLabels != nil {
		t := *r.filterProjectLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[projectLabels][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[projectLabels][]", t, "form", "multi")
		}
	}
	if r.filterIdentification != nil {
		t := *r.filterIdentification
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[identification][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[identification][]", t, "form", "multi")
		}
	}
	if r.filterSeverity != nil {
		t := *r.filterSeverity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[severity][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[severity][]", t, "form", "multi")
		}
	}
	if r.filterFoundAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[foundAfter]", r.filterFoundAfter, "form", "")
	}
	if r.filterHasFix != nil {
		t := *r.filterHasFix
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[hasFix][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[hasFix][]", t, "form", "multi")
		}
	}
	if r.filterUpgradeDistance != nil {
		t := *r.filterUpgradeDistance
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[upgradeDistance][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[upgradeDistance][]", t, "form", "multi")
		}
	}
	if r.filterExploitMaturity != nil {
		t := *r.filterExploitMaturity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[exploitMaturity][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[exploitMaturity][]", t, "form", "multi")
		}
	}
	if r.filterIgnoreReason != nil {
		t := *r.filterIgnoreReason
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ignoreReason][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ignoreReason][]", t, "form", "multi")
		}
	}
	if r.filterLicenses != nil {
		t := *r.filterLicenses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[licenses][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[licenses][]", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssuesRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	category *string
	scopeType *string
	csv *bool
	includeDirectDependencyOriginPaths *bool
	status *string
	scopeId *string
	scopeRevision *string
	scopeRevisionScanId *int32
	scopeRelease *string
	scopeReleaseScanId *string
	scopeCompareToRevision *string
	scopeCompareToChangeStatus *string
	ids *[]int32
	filterRevisionIds *[]string
	filterSearch *string
	filterDepths *[]string
	filterTicketed *[]string
	filterContainerLayers *[]string
	filterType *GetIssueStatusesFilterTypeParameter
	filterPackageManagers *[]string
	filterCwes *[]string
	filterProjectLabels *[]string
	filterIdentification *[]string
	filterSeverity *[]string
	filterFoundAfter *string
	filterHasFix *[]string
	filterUpgradeDistance *[]string
	filterExploitMaturity *[]string
	filterIgnoreReason *[]string
	filterEpss *GetIssueDiffComparisonSummariesFilterEpssParameter
	filterConfidence *[]string
	sort *string
	page *int32
	count *int32
}

// Issue category
func (r ApiGetIssuesRequest) Category(category string) ApiGetIssuesRequest {
	r.category = &category
	return r
}

// Scope of issues to view / update
func (r ApiGetIssuesRequest) ScopeType(scopeType string) ApiGetIssuesRequest {
	r.scopeType = &scopeType
	return r
}

// Retrieves issues as a CSV
func (r ApiGetIssuesRequest) Csv(csv bool) ApiGetIssuesRequest {
	r.csv = &csv
	return r
}

// Include origin paths for the direct dependency responsible for including the revision(s) affected by this issue 
func (r ApiGetIssuesRequest) IncludeDirectDependencyOriginPaths(includeDirectDependencyOriginPaths bool) ApiGetIssuesRequest {
	r.includeDirectDependencyOriginPaths = &includeDirectDependencyOriginPaths
	return r
}

// Issue status
func (r ApiGetIssuesRequest) Status(status string) ApiGetIssuesRequest {
	r.status = &status
	return r
}

// Project or release group ID (required when scope[type] is \&quot;project\&quot; or \&quot;releaseGroup\&quot;)
func (r ApiGetIssuesRequest) ScopeId(scopeId string) ApiGetIssuesRequest {
	r.scopeId = &scopeId
	return r
}

// Revision ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssuesRequest) ScopeRevision(scopeRevision string) ApiGetIssuesRequest {
	r.scopeRevision = &scopeRevision
	return r
}

// Revision scan ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssuesRequest) ScopeRevisionScanId(scopeRevisionScanId int32) ApiGetIssuesRequest {
	r.scopeRevisionScanId = &scopeRevisionScanId
	return r
}

// Release group ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssuesRequest) ScopeRelease(scopeRelease string) ApiGetIssuesRequest {
	r.scopeRelease = &scopeRelease
	return r
}

// Release scan ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssuesRequest) ScopeReleaseScanId(scopeReleaseScanId string) ApiGetIssuesRequest {
	r.scopeReleaseScanId = &scopeReleaseScanId
	return r
}

// The revision ID to compare issues with. Only availabe for Project Scope.
func (r ApiGetIssuesRequest) ScopeCompareToRevision(scopeCompareToRevision string) ApiGetIssuesRequest {
	r.scopeCompareToRevision = &scopeCompareToRevision
	return r
}

// The status of issues to fetch when comparing issues. - New issues are present in the current revision but not in the comparison revision. - Remediated issues are present in the comparison revision but not in the current revision. - Unchanged issues are present in both revisions. Only available for Project Scope. 
func (r ApiGetIssuesRequest) ScopeCompareToChangeStatus(scopeCompareToChangeStatus string) ApiGetIssuesRequest {
	r.scopeCompareToChangeStatus = &scopeCompareToChangeStatus
	return r
}

// Filter by specific issue IDs
func (r ApiGetIssuesRequest) Ids(ids []int32) ApiGetIssuesRequest {
	r.ids = &ids
	return r
}

// Filter by specific revision IDs
func (r ApiGetIssuesRequest) FilterRevisionIds(filterRevisionIds []string) ApiGetIssuesRequest {
	r.filterRevisionIds = &filterRevisionIds
	return r
}

// Filter by package name or CVE (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssuesRequest) FilterSearch(filterSearch string) ApiGetIssuesRequest {
	r.filterSearch = &filterSearch
	return r
}

// Filter by issue depth
func (r ApiGetIssuesRequest) FilterDepths(filterDepths []string) ApiGetIssuesRequest {
	r.filterDepths = &filterDepths
	return r
}

// Filter by ticketed status.  Only available to premium users.
func (r ApiGetIssuesRequest) FilterTicketed(filterTicketed []string) ApiGetIssuesRequest {
	r.filterTicketed = &filterTicketed
	return r
}

// Filter by container layer
func (r ApiGetIssuesRequest) FilterContainerLayers(filterContainerLayers []string) ApiGetIssuesRequest {
	r.filterContainerLayers = &filterContainerLayers
	return r
}

// Filter by licensing issue type (when category is \&quot;licensing\&quot;) or quality issue type (when category is \&quot;quality\&quot;) 
func (r ApiGetIssuesRequest) FilterType(filterType GetIssueStatusesFilterTypeParameter) ApiGetIssuesRequest {
	r.filterType = &filterType
	return r
}

// Filter by specific package managers
func (r ApiGetIssuesRequest) FilterPackageManagers(filterPackageManagers []string) ApiGetIssuesRequest {
	r.filterPackageManagers = &filterPackageManagers
	return r
}

// Filter by specific CWE identifiers
func (r ApiGetIssuesRequest) FilterCwes(filterCwes []string) ApiGetIssuesRequest {
	r.filterCwes = &filterCwes
	return r
}

// Filter by specific project labels
func (r ApiGetIssuesRequest) FilterProjectLabels(filterProjectLabels []string) ApiGetIssuesRequest {
	r.filterProjectLabels = &filterProjectLabels
	return r
}

// Filter by license identification (when category is \&quot;licensing\&quot;)
func (r ApiGetIssuesRequest) FilterIdentification(filterIdentification []string) ApiGetIssuesRequest {
	r.filterIdentification = &filterIdentification
	return r
}

// Filter by vuln severity (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssuesRequest) FilterSeverity(filterSeverity []string) ApiGetIssuesRequest {
	r.filterSeverity = &filterSeverity
	return r
}

// Include only issues found on after a given date.  Only available to premium users
func (r ApiGetIssuesRequest) FilterFoundAfter(filterFoundAfter string) ApiGetIssuesRequest {
	r.filterFoundAfter = &filterFoundAfter
	return r
}

// Filter by vuln fixability (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssuesRequest) FilterHasFix(filterHasFix []string) ApiGetIssuesRequest {
	r.filterHasFix = &filterHasFix
	return r
}

// Filter by vuln upgrade distance (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssuesRequest) FilterUpgradeDistance(filterUpgradeDistance []string) ApiGetIssuesRequest {
	r.filterUpgradeDistance = &filterUpgradeDistance
	return r
}

// Filter by vuln exploit maturity (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssuesRequest) FilterExploitMaturity(filterExploitMaturity []string) ApiGetIssuesRequest {
	r.filterExploitMaturity = &filterExploitMaturity
	return r
}

// Filter by vuln ignore reason (when category is \&quot;vulnerability\&quot;) This value appears in the vulnerabilities.analysis.detail field in CycloneDX SBOM reports 
func (r ApiGetIssuesRequest) FilterIgnoreReason(filterIgnoreReason []string) ApiGetIssuesRequest {
	r.filterIgnoreReason = &filterIgnoreReason
	return r
}

// Filter by epss &#39;score&#39; or &#39;percentile&#39;. All fields are required.  Only available to premium users.
func (r ApiGetIssuesRequest) FilterEpss(filterEpss GetIssueDiffComparisonSummariesFilterEpssParameter) ApiGetIssuesRequest {
	r.filterEpss = &filterEpss
	return r
}

// Filter issues by their binary dependency confidence level(s)
func (r ApiGetIssuesRequest) FilterConfidence(filterConfidence []string) ApiGetIssuesRequest {
	r.filterConfidence = &filterConfidence
	return r
}

// Sort by package name, when the issue was created, or severity (when category is \&quot;vulnerability\&quot;) 
func (r ApiGetIssuesRequest) Sort(sort string) ApiGetIssuesRequest {
	r.sort = &sort
	return r
}

// The specific page of data to return
func (r ApiGetIssuesRequest) Page(page int32) ApiGetIssuesRequest {
	r.page = &page
	return r
}

// The number of items to return in each page of results
func (r ApiGetIssuesRequest) Count(count int32) ApiGetIssuesRequest {
	r.count = &count
	return r
}

func (r ApiGetIssuesRequest) Execute() (*GetIssues200Response, *http.Response, error) {
	return r.ApiService.GetIssuesExecute(r)
}

/*
GetIssues Method for GetIssues

Retrieve multiple issues

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIssuesRequest
*/
func (a *IssuesAPIService) GetIssues(ctx context.Context) ApiGetIssuesRequest {
	return ApiGetIssuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetIssues200Response
func (a *IssuesAPIService) GetIssuesExecute(r ApiGetIssuesRequest) (*GetIssues200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIssues200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.GetIssues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.category == nil {
		return localVarReturnValue, nil, reportError("category is required and must be specified")
	}
	if r.scopeType == nil {
		return localVarReturnValue, nil, reportError("scopeType is required and must be specified")
	}

	if r.csv != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "csv", r.csv, "form", "")
	}
	if r.includeDirectDependencyOriginPaths != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDirectDependencyOriginPaths", r.includeDirectDependencyOriginPaths, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "form", "")
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "scope[type]", r.scopeType, "form", "")
	if r.scopeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[id]", r.scopeId, "form", "")
	}
	if r.scopeRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revision]", r.scopeRevision, "form", "")
	}
	if r.scopeRevisionScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revisionScanId]", r.scopeRevisionScanId, "form", "")
	}
	if r.scopeRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[release]", r.scopeRelease, "form", "")
	}
	if r.scopeReleaseScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[releaseScanId]", r.scopeReleaseScanId, "form", "")
	}
	if r.scopeCompareToRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[compareTo][revision]", r.scopeCompareToRevision, "form", "")
	}
	if r.scopeCompareToChangeStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[compareTo][changeStatus]", r.scopeCompareToChangeStatus, "form", "")
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids[]", t, "form", "multi")
		}
	}
	if r.filterRevisionIds != nil {
		t := *r.filterRevisionIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[revisionIds][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[revisionIds][]", t, "form", "multi")
		}
	}
	if r.filterSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[search]", r.filterSearch, "form", "")
	}
	if r.filterDepths != nil {
		t := *r.filterDepths
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[depths][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[depths][]", t, "form", "multi")
		}
	}
	if r.filterTicketed != nil {
		t := *r.filterTicketed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ticketed][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ticketed][]", t, "form", "multi")
		}
	}
	if r.filterContainerLayers != nil {
		t := *r.filterContainerLayers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[containerLayers][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[containerLayers][]", t, "form", "multi")
		}
	}
	if r.filterType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[type][]", r.filterType, "form", "")
	}
	if r.filterPackageManagers != nil {
		t := *r.filterPackageManagers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[packageManagers][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[packageManagers][]", t, "form", "multi")
		}
	}
	if r.filterCwes != nil {
		t := *r.filterCwes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[cwes][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[cwes][]", t, "form", "multi")
		}
	}
	if r.filterProjectLabels != nil {
		t := *r.filterProjectLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[projectLabels][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[projectLabels][]", t, "form", "multi")
		}
	}
	if r.filterIdentification != nil {
		t := *r.filterIdentification
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[identification][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[identification][]", t, "form", "multi")
		}
	}
	if r.filterSeverity != nil {
		t := *r.filterSeverity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[severity][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[severity][]", t, "form", "multi")
		}
	}
	if r.filterFoundAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[foundAfter]", r.filterFoundAfter, "form", "")
	}
	if r.filterHasFix != nil {
		t := *r.filterHasFix
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[hasFix][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[hasFix][]", t, "form", "multi")
		}
	}
	if r.filterUpgradeDistance != nil {
		t := *r.filterUpgradeDistance
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[upgradeDistance][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[upgradeDistance][]", t, "form", "multi")
		}
	}
	if r.filterExploitMaturity != nil {
		t := *r.filterExploitMaturity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[exploitMaturity][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[exploitMaturity][]", t, "form", "multi")
		}
	}
	if r.filterIgnoreReason != nil {
		t := *r.filterIgnoreReason
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ignoreReason][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ignoreReason][]", t, "form", "multi")
		}
	}
	if r.filterEpss != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[epss]", r.filterEpss, "deepObject", "")
	}
	if r.filterConfidence != nil {
		t := *r.filterConfidence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[confidence][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[confidence][]", t, "form", "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 20
		r.count = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssuesByCategoryRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	scopeType *string
	scopeId *string
	scopeRevision *string
	scopeRevisionScanId *int32
	scopeRelease *string
	scopeReleaseScanId *string
}

// Scope of issues to view / update
func (r ApiGetIssuesByCategoryRequest) ScopeType(scopeType string) ApiGetIssuesByCategoryRequest {
	r.scopeType = &scopeType
	return r
}

// Project or release group ID (required when scope[type] is \&quot;project\&quot; or \&quot;releaseGroup\&quot;)
func (r ApiGetIssuesByCategoryRequest) ScopeId(scopeId string) ApiGetIssuesByCategoryRequest {
	r.scopeId = &scopeId
	return r
}

// Revision ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssuesByCategoryRequest) ScopeRevision(scopeRevision string) ApiGetIssuesByCategoryRequest {
	r.scopeRevision = &scopeRevision
	return r
}

// Revision scan ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssuesByCategoryRequest) ScopeRevisionScanId(scopeRevisionScanId int32) ApiGetIssuesByCategoryRequest {
	r.scopeRevisionScanId = &scopeRevisionScanId
	return r
}

// Release group ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssuesByCategoryRequest) ScopeRelease(scopeRelease string) ApiGetIssuesByCategoryRequest {
	r.scopeRelease = &scopeRelease
	return r
}

// Release scan ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssuesByCategoryRequest) ScopeReleaseScanId(scopeReleaseScanId string) ApiGetIssuesByCategoryRequest {
	r.scopeReleaseScanId = &scopeReleaseScanId
	return r
}

func (r ApiGetIssuesByCategoryRequest) Execute() (*GetIssuesByCategory200Response, *http.Response, error) {
	return r.ApiService.GetIssuesByCategoryExecute(r)
}

/*
GetIssuesByCategory Method for GetIssuesByCategory

Get the number of active issues by category

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIssuesByCategoryRequest
*/
func (a *IssuesAPIService) GetIssuesByCategory(ctx context.Context) ApiGetIssuesByCategoryRequest {
	return ApiGetIssuesByCategoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetIssuesByCategory200Response
func (a *IssuesAPIService) GetIssuesByCategoryExecute(r ApiGetIssuesByCategoryRequest) (*GetIssuesByCategory200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIssuesByCategory200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.GetIssuesByCategory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues/categories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.scopeType == nil {
		return localVarReturnValue, nil, reportError("scopeType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "scope[type]", r.scopeType, "form", "")
	if r.scopeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[id]", r.scopeId, "form", "")
	}
	if r.scopeRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revision]", r.scopeRevision, "form", "")
	}
	if r.scopeRevisionScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revisionScanId]", r.scopeRevisionScanId, "form", "")
	}
	if r.scopeRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[release]", r.scopeRelease, "form", "")
	}
	if r.scopeReleaseScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[releaseScanId]", r.scopeReleaseScanId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssuesByRevisionRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	category *string
	scopeType *string
	status *string
	scopeId *string
	scopeRevision *string
	scopeRevisionScanId *int32
	scopeRelease *string
	scopeReleaseScanId *string
	scopeCompareToRevision *string
	scopeCompareToChangeStatus *string
	ids *[]int32
	filterRevisionIds *[]string
	filterSearch *string
	filterDepths *[]string
	filterTicketed *[]string
	filterContainerLayers *[]string
	filterType *GetIssueStatusesFilterTypeParameter
	filterPackageManagers *[]string
	filterProjectLabels *[]string
	filterIdentification *[]string
	filterSeverity *[]string
	filterFoundAfter *string
	filterHasFix *[]string
	filterUpgradeDistance *[]string
	filterExploitMaturity *[]string
	filterIgnoreReason *[]string
	filterLicenses *[]string
	sort *string
	page *int32
	count *int32
}

// Issue category
func (r ApiGetIssuesByRevisionRequest) Category(category string) ApiGetIssuesByRevisionRequest {
	r.category = &category
	return r
}

// Scope of issues to view / update
func (r ApiGetIssuesByRevisionRequest) ScopeType(scopeType string) ApiGetIssuesByRevisionRequest {
	r.scopeType = &scopeType
	return r
}

// Issue status
func (r ApiGetIssuesByRevisionRequest) Status(status string) ApiGetIssuesByRevisionRequest {
	r.status = &status
	return r
}

// Project or release group ID (required when scope[type] is \&quot;project\&quot; or \&quot;releaseGroup\&quot;)
func (r ApiGetIssuesByRevisionRequest) ScopeId(scopeId string) ApiGetIssuesByRevisionRequest {
	r.scopeId = &scopeId
	return r
}

// Revision ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssuesByRevisionRequest) ScopeRevision(scopeRevision string) ApiGetIssuesByRevisionRequest {
	r.scopeRevision = &scopeRevision
	return r
}

// Revision scan ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssuesByRevisionRequest) ScopeRevisionScanId(scopeRevisionScanId int32) ApiGetIssuesByRevisionRequest {
	r.scopeRevisionScanId = &scopeRevisionScanId
	return r
}

// Release group ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssuesByRevisionRequest) ScopeRelease(scopeRelease string) ApiGetIssuesByRevisionRequest {
	r.scopeRelease = &scopeRelease
	return r
}

// Release scan ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssuesByRevisionRequest) ScopeReleaseScanId(scopeReleaseScanId string) ApiGetIssuesByRevisionRequest {
	r.scopeReleaseScanId = &scopeReleaseScanId
	return r
}

// The revision ID to compare issues with. Only availabe for Project Scope.
func (r ApiGetIssuesByRevisionRequest) ScopeCompareToRevision(scopeCompareToRevision string) ApiGetIssuesByRevisionRequest {
	r.scopeCompareToRevision = &scopeCompareToRevision
	return r
}

// The status of issues to fetch when comparing issues. - New issues are present in the current revision but not in the comparison revision. - Remediated issues are present in the comparison revision but not in the current revision. - Unchanged issues are present in both revisions. Only available for Project Scope. 
func (r ApiGetIssuesByRevisionRequest) ScopeCompareToChangeStatus(scopeCompareToChangeStatus string) ApiGetIssuesByRevisionRequest {
	r.scopeCompareToChangeStatus = &scopeCompareToChangeStatus
	return r
}

// Filter by specific issue IDs
func (r ApiGetIssuesByRevisionRequest) Ids(ids []int32) ApiGetIssuesByRevisionRequest {
	r.ids = &ids
	return r
}

// Filter by specific revision IDs
func (r ApiGetIssuesByRevisionRequest) FilterRevisionIds(filterRevisionIds []string) ApiGetIssuesByRevisionRequest {
	r.filterRevisionIds = &filterRevisionIds
	return r
}

// Filter by package name or CVE (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssuesByRevisionRequest) FilterSearch(filterSearch string) ApiGetIssuesByRevisionRequest {
	r.filterSearch = &filterSearch
	return r
}

// Filter by issue depth
func (r ApiGetIssuesByRevisionRequest) FilterDepths(filterDepths []string) ApiGetIssuesByRevisionRequest {
	r.filterDepths = &filterDepths
	return r
}

// Filter by ticketed status.  Only available to premium users.
func (r ApiGetIssuesByRevisionRequest) FilterTicketed(filterTicketed []string) ApiGetIssuesByRevisionRequest {
	r.filterTicketed = &filterTicketed
	return r
}

// Filter by container layer
func (r ApiGetIssuesByRevisionRequest) FilterContainerLayers(filterContainerLayers []string) ApiGetIssuesByRevisionRequest {
	r.filterContainerLayers = &filterContainerLayers
	return r
}

// Filter by licensing issue type (when category is \&quot;licensing\&quot;) or quality issue type (when category is \&quot;quality\&quot;) 
func (r ApiGetIssuesByRevisionRequest) FilterType(filterType GetIssueStatusesFilterTypeParameter) ApiGetIssuesByRevisionRequest {
	r.filterType = &filterType
	return r
}

// Filter by specific package managers
func (r ApiGetIssuesByRevisionRequest) FilterPackageManagers(filterPackageManagers []string) ApiGetIssuesByRevisionRequest {
	r.filterPackageManagers = &filterPackageManagers
	return r
}

// Filter by specific project labels
func (r ApiGetIssuesByRevisionRequest) FilterProjectLabels(filterProjectLabels []string) ApiGetIssuesByRevisionRequest {
	r.filterProjectLabels = &filterProjectLabels
	return r
}

// Filter by license identification (when category is \&quot;licensing\&quot;)
func (r ApiGetIssuesByRevisionRequest) FilterIdentification(filterIdentification []string) ApiGetIssuesByRevisionRequest {
	r.filterIdentification = &filterIdentification
	return r
}

// Filter by vuln severity (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssuesByRevisionRequest) FilterSeverity(filterSeverity []string) ApiGetIssuesByRevisionRequest {
	r.filterSeverity = &filterSeverity
	return r
}

// Include only issues found on after a given date.  Only available to premium users
func (r ApiGetIssuesByRevisionRequest) FilterFoundAfter(filterFoundAfter string) ApiGetIssuesByRevisionRequest {
	r.filterFoundAfter = &filterFoundAfter
	return r
}

// Filter by vuln fixability (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssuesByRevisionRequest) FilterHasFix(filterHasFix []string) ApiGetIssuesByRevisionRequest {
	r.filterHasFix = &filterHasFix
	return r
}

// Filter by vuln upgrade distance (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssuesByRevisionRequest) FilterUpgradeDistance(filterUpgradeDistance []string) ApiGetIssuesByRevisionRequest {
	r.filterUpgradeDistance = &filterUpgradeDistance
	return r
}

// Filter by vuln exploit maturity (when category is \&quot;vulnerability\&quot;)
func (r ApiGetIssuesByRevisionRequest) FilterExploitMaturity(filterExploitMaturity []string) ApiGetIssuesByRevisionRequest {
	r.filterExploitMaturity = &filterExploitMaturity
	return r
}

// Filter by vuln ignore reason (when category is \&quot;vulnerability\&quot;) This value appears in the vulnerabilities.analysis.detail field in CycloneDX SBOM reports 
func (r ApiGetIssuesByRevisionRequest) FilterIgnoreReason(filterIgnoreReason []string) ApiGetIssuesByRevisionRequest {
	r.filterIgnoreReason = &filterIgnoreReason
	return r
}

// Filter by issues affected by a set of license ID&#39;s (when category is \&quot;licensing\&quot;)
func (r ApiGetIssuesByRevisionRequest) FilterLicenses(filterLicenses []string) ApiGetIssuesByRevisionRequest {
	r.filterLicenses = &filterLicenses
	return r
}

// Sort by package name, when the issue was created, or total number of issues 
func (r ApiGetIssuesByRevisionRequest) Sort(sort string) ApiGetIssuesByRevisionRequest {
	r.sort = &sort
	return r
}

// The specific page of data to return
func (r ApiGetIssuesByRevisionRequest) Page(page int32) ApiGetIssuesByRevisionRequest {
	r.page = &page
	return r
}

// The number of items to return in each page of results
func (r ApiGetIssuesByRevisionRequest) Count(count int32) ApiGetIssuesByRevisionRequest {
	r.count = &count
	return r
}

func (r ApiGetIssuesByRevisionRequest) Execute() (*GetIssuesByRevision200Response, *http.Response, error) {
	return r.ApiService.GetIssuesByRevisionExecute(r)
}

/*
GetIssuesByRevision Method for GetIssuesByRevision

Retrieve issue metadata that is grouped by revision

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIssuesByRevisionRequest
*/
func (a *IssuesAPIService) GetIssuesByRevision(ctx context.Context) ApiGetIssuesByRevisionRequest {
	return ApiGetIssuesByRevisionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetIssuesByRevision200Response
func (a *IssuesAPIService) GetIssuesByRevisionExecute(r ApiGetIssuesByRevisionRequest) (*GetIssuesByRevision200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIssuesByRevision200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.GetIssuesByRevision")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues/revisions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.category == nil {
		return localVarReturnValue, nil, reportError("category is required and must be specified")
	}
	if r.scopeType == nil {
		return localVarReturnValue, nil, reportError("scopeType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "form", "")
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "scope[type]", r.scopeType, "form", "")
	if r.scopeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[id]", r.scopeId, "form", "")
	}
	if r.scopeRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revision]", r.scopeRevision, "form", "")
	}
	if r.scopeRevisionScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revisionScanId]", r.scopeRevisionScanId, "form", "")
	}
	if r.scopeRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[release]", r.scopeRelease, "form", "")
	}
	if r.scopeReleaseScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[releaseScanId]", r.scopeReleaseScanId, "form", "")
	}
	if r.scopeCompareToRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[compareTo][revision]", r.scopeCompareToRevision, "form", "")
	}
	if r.scopeCompareToChangeStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[compareTo][changeStatus]", r.scopeCompareToChangeStatus, "form", "")
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids[]", t, "form", "multi")
		}
	}
	if r.filterRevisionIds != nil {
		t := *r.filterRevisionIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[revisionIds][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[revisionIds][]", t, "form", "multi")
		}
	}
	if r.filterSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[search]", r.filterSearch, "form", "")
	}
	if r.filterDepths != nil {
		t := *r.filterDepths
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[depths][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[depths][]", t, "form", "multi")
		}
	}
	if r.filterTicketed != nil {
		t := *r.filterTicketed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ticketed][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ticketed][]", t, "form", "multi")
		}
	}
	if r.filterContainerLayers != nil {
		t := *r.filterContainerLayers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[containerLayers][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[containerLayers][]", t, "form", "multi")
		}
	}
	if r.filterType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[type][]", r.filterType, "form", "")
	}
	if r.filterPackageManagers != nil {
		t := *r.filterPackageManagers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[packageManagers][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[packageManagers][]", t, "form", "multi")
		}
	}
	if r.filterProjectLabels != nil {
		t := *r.filterProjectLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[projectLabels][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[projectLabels][]", t, "form", "multi")
		}
	}
	if r.filterIdentification != nil {
		t := *r.filterIdentification
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[identification][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[identification][]", t, "form", "multi")
		}
	}
	if r.filterSeverity != nil {
		t := *r.filterSeverity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[severity][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[severity][]", t, "form", "multi")
		}
	}
	if r.filterFoundAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[foundAfter]", r.filterFoundAfter, "form", "")
	}
	if r.filterHasFix != nil {
		t := *r.filterHasFix
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[hasFix][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[hasFix][]", t, "form", "multi")
		}
	}
	if r.filterUpgradeDistance != nil {
		t := *r.filterUpgradeDistance
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[upgradeDistance][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[upgradeDistance][]", t, "form", "multi")
		}
	}
	if r.filterExploitMaturity != nil {
		t := *r.filterExploitMaturity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[exploitMaturity][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[exploitMaturity][]", t, "form", "multi")
		}
	}
	if r.filterIgnoreReason != nil {
		t := *r.filterIgnoreReason
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ignoreReason][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ignoreReason][]", t, "form", "multi")
		}
	}
	if r.filterLicenses != nil {
		t := *r.filterLicenses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[licenses][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[licenses][]", t, "form", "multi")
		}
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 20
		r.count = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssuesByTypeRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	scopeType *string
	scopeId *string
	scopeRevision *string
	scopeRevisionScanId *int32
	scopeRelease *string
	scopeReleaseScanId *string
}

// Scope of issues to view / update
func (r ApiGetIssuesByTypeRequest) ScopeType(scopeType string) ApiGetIssuesByTypeRequest {
	r.scopeType = &scopeType
	return r
}

// Project or release group ID (required when scope[type] is \&quot;project\&quot; or \&quot;releaseGroup\&quot;)
func (r ApiGetIssuesByTypeRequest) ScopeId(scopeId string) ApiGetIssuesByTypeRequest {
	r.scopeId = &scopeId
	return r
}

// Revision ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssuesByTypeRequest) ScopeRevision(scopeRevision string) ApiGetIssuesByTypeRequest {
	r.scopeRevision = &scopeRevision
	return r
}

// Revision scan ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetIssuesByTypeRequest) ScopeRevisionScanId(scopeRevisionScanId int32) ApiGetIssuesByTypeRequest {
	r.scopeRevisionScanId = &scopeRevisionScanId
	return r
}

// Release group ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssuesByTypeRequest) ScopeRelease(scopeRelease string) ApiGetIssuesByTypeRequest {
	r.scopeRelease = &scopeRelease
	return r
}

// Release scan ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetIssuesByTypeRequest) ScopeReleaseScanId(scopeReleaseScanId string) ApiGetIssuesByTypeRequest {
	r.scopeReleaseScanId = &scopeReleaseScanId
	return r
}

func (r ApiGetIssuesByTypeRequest) Execute() (*GetIssuesByType200Response, *http.Response, error) {
	return r.ApiService.GetIssuesByTypeExecute(r)
}

/*
GetIssuesByType Method for GetIssuesByType

Get the number of active issues by type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIssuesByTypeRequest
*/
func (a *IssuesAPIService) GetIssuesByType(ctx context.Context) ApiGetIssuesByTypeRequest {
	return ApiGetIssuesByTypeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetIssuesByType200Response
func (a *IssuesAPIService) GetIssuesByTypeExecute(r ApiGetIssuesByTypeRequest) (*GetIssuesByType200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetIssuesByType200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.GetIssuesByType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues/types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.scopeType == nil {
		return localVarReturnValue, nil, reportError("scopeType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "scope[type]", r.scopeType, "form", "")
	if r.scopeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[id]", r.scopeId, "form", "")
	}
	if r.scopeRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revision]", r.scopeRevision, "form", "")
	}
	if r.scopeRevisionScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revisionScanId]", r.scopeRevisionScanId, "form", "")
	}
	if r.scopeRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[release]", r.scopeRelease, "form", "")
	}
	if r.scopeReleaseScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[releaseScanId]", r.scopeReleaseScanId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLicenseListRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	category *string
	scopeType *string
	scopeId *string
	scopeRevision *string
	scopeRevisionScanId *int32
	scopeRelease *string
	scopeReleaseScanId *string
}

// Issue category (must be licensing)
func (r ApiGetLicenseListRequest) Category(category string) ApiGetLicenseListRequest {
	r.category = &category
	return r
}

// Scope of issues to view / update
func (r ApiGetLicenseListRequest) ScopeType(scopeType string) ApiGetLicenseListRequest {
	r.scopeType = &scopeType
	return r
}

// Project or release group ID (required when scope[type] is \&quot;project\&quot; or \&quot;releaseGroup\&quot;)
func (r ApiGetLicenseListRequest) ScopeId(scopeId string) ApiGetLicenseListRequest {
	r.scopeId = &scopeId
	return r
}

// Revision ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetLicenseListRequest) ScopeRevision(scopeRevision string) ApiGetLicenseListRequest {
	r.scopeRevision = &scopeRevision
	return r
}

// Revision scan ID (when scope[type] is \&quot;project\&quot;)
func (r ApiGetLicenseListRequest) ScopeRevisionScanId(scopeRevisionScanId int32) ApiGetLicenseListRequest {
	r.scopeRevisionScanId = &scopeRevisionScanId
	return r
}

// Release group ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetLicenseListRequest) ScopeRelease(scopeRelease string) ApiGetLicenseListRequest {
	r.scopeRelease = &scopeRelease
	return r
}

// Release scan ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiGetLicenseListRequest) ScopeReleaseScanId(scopeReleaseScanId string) ApiGetLicenseListRequest {
	r.scopeReleaseScanId = &scopeReleaseScanId
	return r
}

func (r ApiGetLicenseListRequest) Execute() (*GetLicenseList200Response, *http.Response, error) {
	return r.ApiService.GetLicenseListExecute(r)
}

/*
GetLicenseList Method for GetLicenseList

Get a sorted list of license ID's, matching the provided filters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLicenseListRequest
*/
func (a *IssuesAPIService) GetLicenseList(ctx context.Context) ApiGetLicenseListRequest {
	return ApiGetLicenseListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetLicenseList200Response
func (a *IssuesAPIService) GetLicenseListExecute(r ApiGetLicenseListRequest) (*GetLicenseList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetLicenseList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.GetLicenseList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues/license-list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.category == nil {
		return localVarReturnValue, nil, reportError("category is required and must be specified")
	}
	if r.scopeType == nil {
		return localVarReturnValue, nil, reportError("scopeType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "scope[type]", r.scopeType, "form", "")
	if r.scopeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[id]", r.scopeId, "form", "")
	}
	if r.scopeRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revision]", r.scopeRevision, "form", "")
	}
	if r.scopeRevisionScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revisionScanId]", r.scopeRevisionScanId, "form", "")
	}
	if r.scopeRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[release]", r.scopeRelease, "form", "")
	}
	if r.scopeReleaseScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[releaseScanId]", r.scopeReleaseScanId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectCSVExportIssuesRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	locator string
	revisionId *string
	status *interface{}
	ref *string
	refType *string
}

// The revisionId of the project to get issues for. If not provided, the latest revision will be used.
func (r ApiGetProjectCSVExportIssuesRequest) RevisionId(revisionId string) ApiGetProjectCSVExportIssuesRequest {
	r.revisionId = &revisionId
	return r
}

// The status of the issues to return. If not provided, all active issues will be returned.
func (r ApiGetProjectCSVExportIssuesRequest) Status(status interface{}) ApiGetProjectCSVExportIssuesRequest {
	r.status = &status
	return r
}

// the branch or tag to get issues for. If not provided, the default branch will be used.
func (r ApiGetProjectCSVExportIssuesRequest) Ref(ref string) ApiGetProjectCSVExportIssuesRequest {
	r.ref = &ref
	return r
}

// Specify whether the ref is a branch or tag.
func (r ApiGetProjectCSVExportIssuesRequest) RefType(refType string) ApiGetProjectCSVExportIssuesRequest {
	r.refType = &refType
	return r
}

func (r ApiGetProjectCSVExportIssuesRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetProjectCSVExportIssuesExecute(r)
}

/*
GetProjectCSVExportIssues Method for GetProjectCSVExportIssues

This endpoint returns a CSV file of all issues for the project.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator the url-encoded locator of the project
 @return ApiGetProjectCSVExportIssuesRequest
*/
func (a *IssuesAPIService) GetProjectCSVExportIssues(ctx context.Context, locator string) ApiGetProjectCSVExportIssuesRequest {
	return ApiGetProjectCSVExportIssuesRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
//  @return string
func (a *IssuesAPIService) GetProjectCSVExportIssuesExecute(r ApiGetProjectCSVExportIssuesRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.GetProjectCSVExportIssues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{locator}/export-issues/csv"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.revisionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revisionId", r.revisionId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.ref != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ref", r.ref, "form", "")
	}
	if r.refType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ref_type", r.refType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectExportIssuesRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	locator string
	format *interface{}
	revisionId *string
	status *interface{}
	ref *string
	refType *string
}

// report format to return (JSON or CSV). If not provided, JSON will be returned.
func (r ApiGetProjectExportIssuesRequest) Format(format interface{}) ApiGetProjectExportIssuesRequest {
	r.format = &format
	return r
}

// The revisionId of the project to get issues for. If not provided, the latest revision will be used.
func (r ApiGetProjectExportIssuesRequest) RevisionId(revisionId string) ApiGetProjectExportIssuesRequest {
	r.revisionId = &revisionId
	return r
}

// The status of the issues to return. If not provided, all active issues will be returned.
func (r ApiGetProjectExportIssuesRequest) Status(status interface{}) ApiGetProjectExportIssuesRequest {
	r.status = &status
	return r
}

// the branch or tag to get issues for. If not provided, the default branch will be used.
func (r ApiGetProjectExportIssuesRequest) Ref(ref string) ApiGetProjectExportIssuesRequest {
	r.ref = &ref
	return r
}

// Specify whether the ref is a branch or tag.
func (r ApiGetProjectExportIssuesRequest) RefType(refType string) ApiGetProjectExportIssuesRequest {
	r.refType = &refType
	return r
}

func (r ApiGetProjectExportIssuesRequest) Execute() (*GetProjectExportIssues200Response, *http.Response, error) {
	return r.ApiService.GetProjectExportIssuesExecute(r)
}

/*
GetProjectExportIssues Method for GetProjectExportIssues

This endpoint returns a list of all issues for a project. The issues are exported in a JSON (or CSV) format.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator the url-encoded locator of the project
 @return ApiGetProjectExportIssuesRequest
*/
func (a *IssuesAPIService) GetProjectExportIssues(ctx context.Context, locator string) ApiGetProjectExportIssuesRequest {
	return ApiGetProjectExportIssuesRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
//  @return GetProjectExportIssues200Response
func (a *IssuesAPIService) GetProjectExportIssuesExecute(r ApiGetProjectExportIssuesRequest) (*GetProjectExportIssues200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProjectExportIssues200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.GetProjectExportIssues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{locator}/export-issues"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.revisionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revisionId", r.revisionId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.ref != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ref", r.ref, "form", "")
	}
	if r.refType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ref_type", r.refType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectJSONExportIssuesRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	locator string
	revisionId *string
	status *interface{}
	ref *string
	refType *string
}

// The revisionId of the project to get issues for. If not provided, the latest revision will be used.
func (r ApiGetProjectJSONExportIssuesRequest) RevisionId(revisionId string) ApiGetProjectJSONExportIssuesRequest {
	r.revisionId = &revisionId
	return r
}

// The status of the issues to return. If not provided, all active issues will be returned.
func (r ApiGetProjectJSONExportIssuesRequest) Status(status interface{}) ApiGetProjectJSONExportIssuesRequest {
	r.status = &status
	return r
}

// the branch or tag to get issues for. If not provided, the default branch will be used.
func (r ApiGetProjectJSONExportIssuesRequest) Ref(ref string) ApiGetProjectJSONExportIssuesRequest {
	r.ref = &ref
	return r
}

// Specify whether the ref is a branch or tag.
func (r ApiGetProjectJSONExportIssuesRequest) RefType(refType string) ApiGetProjectJSONExportIssuesRequest {
	r.refType = &refType
	return r
}

func (r ApiGetProjectJSONExportIssuesRequest) Execute() (*GetProjectJSONExportIssues200Response, *http.Response, error) {
	return r.ApiService.GetProjectJSONExportIssuesExecute(r)
}

/*
GetProjectJSONExportIssues Method for GetProjectJSONExportIssues

This endpoint returns a list of all issues for a project. The issues are exported in a JSON format.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param locator the url-encoded locator of the project
 @return ApiGetProjectJSONExportIssuesRequest
*/
func (a *IssuesAPIService) GetProjectJSONExportIssues(ctx context.Context, locator string) ApiGetProjectJSONExportIssuesRequest {
	return ApiGetProjectJSONExportIssuesRequest{
		ApiService: a,
		ctx: ctx,
		locator: locator,
	}
}

// Execute executes the request
//  @return GetProjectJSONExportIssues200Response
func (a *IssuesAPIService) GetProjectJSONExportIssuesExecute(r ApiGetProjectJSONExportIssuesRequest) (*GetProjectJSONExportIssues200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProjectJSONExportIssues200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.GetProjectJSONExportIssues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects/{locator}/export-issues/json"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.revisionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revisionId", r.revisionId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.ref != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ref", r.ref, "form", "")
	}
	if r.refType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ref_type", r.refType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 428 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateIssuesRequest struct {
	ctx context.Context
	ApiService *IssuesAPIService
	category *string
	scopeType *string
	status *string
	scopeId *string
	scopeRevision *string
	scopeRevisionScanId *int32
	scopeRelease *string
	scopeReleaseScanId *string
	scopeCompareToRevision *string
	scopeCompareToChangeStatus *string
	ids *[]int32
	filterRevisionIds *[]string
	filterSearch *string
	filterDepths *[]string
	filterTicketed *[]string
	filterContainerLayers *[]string
	filterType *GetIssueStatusesFilterTypeParameter
	filterPackageManagers *[]string
	filterProjectLabels *[]string
	filterIdentification *[]string
	filterSeverity *[]string
	filterFoundAfter *string
	filterHasFix *[]string
	filterUpgradeDistance *[]string
	filterExploitMaturity *[]string
	filterIgnoreReason *[]string
	filterLicenses *[]string
	filterConfidence *[]string
	updateIssuesRequest *UpdateIssuesRequest
}

// Issue category
func (r ApiUpdateIssuesRequest) Category(category string) ApiUpdateIssuesRequest {
	r.category = &category
	return r
}

// Scope of issues to view / update
func (r ApiUpdateIssuesRequest) ScopeType(scopeType string) ApiUpdateIssuesRequest {
	r.scopeType = &scopeType
	return r
}

// Issue status
func (r ApiUpdateIssuesRequest) Status(status string) ApiUpdateIssuesRequest {
	r.status = &status
	return r
}

// Project or release group ID (required when scope[type] is \&quot;project\&quot; or \&quot;releaseGroup\&quot;)
func (r ApiUpdateIssuesRequest) ScopeId(scopeId string) ApiUpdateIssuesRequest {
	r.scopeId = &scopeId
	return r
}

// Revision ID (when scope[type] is \&quot;project\&quot;)
func (r ApiUpdateIssuesRequest) ScopeRevision(scopeRevision string) ApiUpdateIssuesRequest {
	r.scopeRevision = &scopeRevision
	return r
}

// Revision scan ID (when scope[type] is \&quot;project\&quot;)
func (r ApiUpdateIssuesRequest) ScopeRevisionScanId(scopeRevisionScanId int32) ApiUpdateIssuesRequest {
	r.scopeRevisionScanId = &scopeRevisionScanId
	return r
}

// Release group ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiUpdateIssuesRequest) ScopeRelease(scopeRelease string) ApiUpdateIssuesRequest {
	r.scopeRelease = &scopeRelease
	return r
}

// Release scan ID (when scope[type] is \&quot;releaseGroup\&quot;)
func (r ApiUpdateIssuesRequest) ScopeReleaseScanId(scopeReleaseScanId string) ApiUpdateIssuesRequest {
	r.scopeReleaseScanId = &scopeReleaseScanId
	return r
}

// The revision ID to compare issues with. Only availabe for Project Scope.
func (r ApiUpdateIssuesRequest) ScopeCompareToRevision(scopeCompareToRevision string) ApiUpdateIssuesRequest {
	r.scopeCompareToRevision = &scopeCompareToRevision
	return r
}

// The status of issues to fetch when comparing issues. - New issues are present in the current revision but not in the comparison revision. - Remediated issues are present in the comparison revision but not in the current revision. - Unchanged issues are present in both revisions. Only available for Project Scope. 
func (r ApiUpdateIssuesRequest) ScopeCompareToChangeStatus(scopeCompareToChangeStatus string) ApiUpdateIssuesRequest {
	r.scopeCompareToChangeStatus = &scopeCompareToChangeStatus
	return r
}

// Filter by specific issue IDs
func (r ApiUpdateIssuesRequest) Ids(ids []int32) ApiUpdateIssuesRequest {
	r.ids = &ids
	return r
}

// Filter by specific revision IDs
func (r ApiUpdateIssuesRequest) FilterRevisionIds(filterRevisionIds []string) ApiUpdateIssuesRequest {
	r.filterRevisionIds = &filterRevisionIds
	return r
}

// Filter by package name or CVE (when category is \&quot;vulnerability\&quot;)
func (r ApiUpdateIssuesRequest) FilterSearch(filterSearch string) ApiUpdateIssuesRequest {
	r.filterSearch = &filterSearch
	return r
}

// Filter by issue depth
func (r ApiUpdateIssuesRequest) FilterDepths(filterDepths []string) ApiUpdateIssuesRequest {
	r.filterDepths = &filterDepths
	return r
}

// Filter by ticketed status.  Only available to premium users.
func (r ApiUpdateIssuesRequest) FilterTicketed(filterTicketed []string) ApiUpdateIssuesRequest {
	r.filterTicketed = &filterTicketed
	return r
}

// Filter by container layer
func (r ApiUpdateIssuesRequest) FilterContainerLayers(filterContainerLayers []string) ApiUpdateIssuesRequest {
	r.filterContainerLayers = &filterContainerLayers
	return r
}

// Filter by licensing issue type (when category is \&quot;licensing\&quot;) or quality issue type (when category is \&quot;quality\&quot;) 
func (r ApiUpdateIssuesRequest) FilterType(filterType GetIssueStatusesFilterTypeParameter) ApiUpdateIssuesRequest {
	r.filterType = &filterType
	return r
}

// Filter by specific package managers
func (r ApiUpdateIssuesRequest) FilterPackageManagers(filterPackageManagers []string) ApiUpdateIssuesRequest {
	r.filterPackageManagers = &filterPackageManagers
	return r
}

// Filter by specific project labels
func (r ApiUpdateIssuesRequest) FilterProjectLabels(filterProjectLabels []string) ApiUpdateIssuesRequest {
	r.filterProjectLabels = &filterProjectLabels
	return r
}

// Filter by license identification (when category is \&quot;licensing\&quot;)
func (r ApiUpdateIssuesRequest) FilterIdentification(filterIdentification []string) ApiUpdateIssuesRequest {
	r.filterIdentification = &filterIdentification
	return r
}

// Filter by vuln severity (when category is \&quot;vulnerability\&quot;)
func (r ApiUpdateIssuesRequest) FilterSeverity(filterSeverity []string) ApiUpdateIssuesRequest {
	r.filterSeverity = &filterSeverity
	return r
}

// Include only issues found on after a given date.  Only available to premium users
func (r ApiUpdateIssuesRequest) FilterFoundAfter(filterFoundAfter string) ApiUpdateIssuesRequest {
	r.filterFoundAfter = &filterFoundAfter
	return r
}

// Filter by vuln fixability (when category is \&quot;vulnerability\&quot;)
func (r ApiUpdateIssuesRequest) FilterHasFix(filterHasFix []string) ApiUpdateIssuesRequest {
	r.filterHasFix = &filterHasFix
	return r
}

// Filter by vuln upgrade distance (when category is \&quot;vulnerability\&quot;)
func (r ApiUpdateIssuesRequest) FilterUpgradeDistance(filterUpgradeDistance []string) ApiUpdateIssuesRequest {
	r.filterUpgradeDistance = &filterUpgradeDistance
	return r
}

// Filter by vuln exploit maturity (when category is \&quot;vulnerability\&quot;)
func (r ApiUpdateIssuesRequest) FilterExploitMaturity(filterExploitMaturity []string) ApiUpdateIssuesRequest {
	r.filterExploitMaturity = &filterExploitMaturity
	return r
}

// Filter by vuln ignore reason (when category is \&quot;vulnerability\&quot;) This value appears in the vulnerabilities.analysis.detail field in CycloneDX SBOM reports 
func (r ApiUpdateIssuesRequest) FilterIgnoreReason(filterIgnoreReason []string) ApiUpdateIssuesRequest {
	r.filterIgnoreReason = &filterIgnoreReason
	return r
}

// Filter by issues affected by a set of license ID&#39;s (when category is \&quot;licensing\&quot;)
func (r ApiUpdateIssuesRequest) FilterLicenses(filterLicenses []string) ApiUpdateIssuesRequest {
	r.filterLicenses = &filterLicenses
	return r
}

// Filter issues by their binary dependency confidence level(s)
func (r ApiUpdateIssuesRequest) FilterConfidence(filterConfidence []string) ApiUpdateIssuesRequest {
	r.filterConfidence = &filterConfidence
	return r
}

func (r ApiUpdateIssuesRequest) UpdateIssuesRequest(updateIssuesRequest UpdateIssuesRequest) ApiUpdateIssuesRequest {
	r.updateIssuesRequest = &updateIssuesRequest
	return r
}

func (r ApiUpdateIssuesRequest) Execute() (*UpdateIssues200Response, *http.Response, error) {
	return r.ApiService.UpdateIssuesExecute(r)
}

/*
UpdateIssues Method for UpdateIssues

Apply actions to the current selection of issues or set of applied filters.  Note that Issue Exports are only allowed for premium users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateIssuesRequest
*/
func (a *IssuesAPIService) UpdateIssues(ctx context.Context) ApiUpdateIssuesRequest {
	return ApiUpdateIssuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateIssues200Response
func (a *IssuesAPIService) UpdateIssuesExecute(r ApiUpdateIssuesRequest) (*UpdateIssues200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateIssues200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuesAPIService.UpdateIssues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/issues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.category == nil {
		return localVarReturnValue, nil, reportError("category is required and must be specified")
	}
	if r.scopeType == nil {
		return localVarReturnValue, nil, reportError("scopeType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "form", "")
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "scope[type]", r.scopeType, "form", "")
	if r.scopeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[id]", r.scopeId, "form", "")
	}
	if r.scopeRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revision]", r.scopeRevision, "form", "")
	}
	if r.scopeRevisionScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[revisionScanId]", r.scopeRevisionScanId, "form", "")
	}
	if r.scopeRelease != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[release]", r.scopeRelease, "form", "")
	}
	if r.scopeReleaseScanId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[releaseScanId]", r.scopeReleaseScanId, "form", "")
	}
	if r.scopeCompareToRevision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[compareTo][revision]", r.scopeCompareToRevision, "form", "")
	}
	if r.scopeCompareToChangeStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope[compareTo][changeStatus]", r.scopeCompareToChangeStatus, "form", "")
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids[]", t, "form", "multi")
		}
	}
	if r.filterRevisionIds != nil {
		t := *r.filterRevisionIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[revisionIds][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[revisionIds][]", t, "form", "multi")
		}
	}
	if r.filterSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[search]", r.filterSearch, "form", "")
	}
	if r.filterDepths != nil {
		t := *r.filterDepths
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[depths][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[depths][]", t, "form", "multi")
		}
	}
	if r.filterTicketed != nil {
		t := *r.filterTicketed
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ticketed][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ticketed][]", t, "form", "multi")
		}
	}
	if r.filterContainerLayers != nil {
		t := *r.filterContainerLayers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[containerLayers][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[containerLayers][]", t, "form", "multi")
		}
	}
	if r.filterType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[type][]", r.filterType, "form", "")
	}
	if r.filterPackageManagers != nil {
		t := *r.filterPackageManagers
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[packageManagers][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[packageManagers][]", t, "form", "multi")
		}
	}
	if r.filterProjectLabels != nil {
		t := *r.filterProjectLabels
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[projectLabels][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[projectLabels][]", t, "form", "multi")
		}
	}
	if r.filterIdentification != nil {
		t := *r.filterIdentification
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[identification][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[identification][]", t, "form", "multi")
		}
	}
	if r.filterSeverity != nil {
		t := *r.filterSeverity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[severity][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[severity][]", t, "form", "multi")
		}
	}
	if r.filterFoundAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[foundAfter]", r.filterFoundAfter, "form", "")
	}
	if r.filterHasFix != nil {
		t := *r.filterHasFix
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[hasFix][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[hasFix][]", t, "form", "multi")
		}
	}
	if r.filterUpgradeDistance != nil {
		t := *r.filterUpgradeDistance
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[upgradeDistance][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[upgradeDistance][]", t, "form", "multi")
		}
	}
	if r.filterExploitMaturity != nil {
		t := *r.filterExploitMaturity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[exploitMaturity][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[exploitMaturity][]", t, "form", "multi")
		}
	}
	if r.filterIgnoreReason != nil {
		t := *r.filterIgnoreReason
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ignoreReason][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[ignoreReason][]", t, "form", "multi")
		}
	}
	if r.filterLicenses != nil {
		t := *r.filterLicenses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[licenses][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[licenses][]", t, "form", "multi")
		}
	}
	if r.filterConfidence != nil {
		t := *r.filterConfidence
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filter[confidence][]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filter[confidence][]", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateIssuesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
