/*
FOSSA API

OpenAPI Specification for public FOSSA APIs

API version: 4.28.61
Contact: support@fossa.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fossa

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ReleaseGroupsAPIService ReleaseGroupsAPI service
type ReleaseGroupsAPIService service

type ApiCreateReleaseGroupRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	createReleaseGroupRequest *CreateReleaseGroupRequest
}

func (r ApiCreateReleaseGroupRequest) CreateReleaseGroupRequest(createReleaseGroupRequest CreateReleaseGroupRequest) ApiCreateReleaseGroupRequest {
	r.createReleaseGroupRequest = &createReleaseGroupRequest
	return r
}

func (r ApiCreateReleaseGroupRequest) Execute() (*CreateReleaseGroup200Response, *http.Response, error) {
	return r.ApiService.CreateReleaseGroupExecute(r)
}

/*
CreateReleaseGroup Method for CreateReleaseGroup

Used to create a release group.  Fails if user's organization is at or over the release group limit.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateReleaseGroupRequest
*/
func (a *ReleaseGroupsAPIService) CreateReleaseGroup(ctx context.Context) ApiCreateReleaseGroupRequest {
	return ApiCreateReleaseGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateReleaseGroup200Response
func (a *ReleaseGroupsAPIService) CreateReleaseGroupExecute(r ApiCreateReleaseGroupRequest) (*CreateReleaseGroup200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateReleaseGroup200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.CreateReleaseGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createReleaseGroupRequest == nil {
		return localVarReturnValue, nil, reportError("createReleaseGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createReleaseGroupRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateReleaseGroupReleasesRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
	createReleaseGroupReleasesRequest *CreateReleaseGroupReleasesRequest
}

func (r ApiCreateReleaseGroupReleasesRequest) CreateReleaseGroupReleasesRequest(createReleaseGroupReleasesRequest CreateReleaseGroupReleasesRequest) ApiCreateReleaseGroupReleasesRequest {
	r.createReleaseGroupReleasesRequest = &createReleaseGroupReleasesRequest
	return r
}

func (r ApiCreateReleaseGroupReleasesRequest) Execute() (*CreateReleaseGroup200Response, *http.Response, error) {
	return r.ApiService.CreateReleaseGroupReleasesExecute(r)
}

/*
CreateReleaseGroupReleases Method for CreateReleaseGroupReleases

Creates a new release for a given release group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The ID of the release group
 @return ApiCreateReleaseGroupReleasesRequest
*/
func (a *ReleaseGroupsAPIService) CreateReleaseGroupReleases(ctx context.Context, groupId int32) ApiCreateReleaseGroupReleasesRequest {
	return ApiCreateReleaseGroupReleasesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CreateReleaseGroup200Response
func (a *ReleaseGroupsAPIService) CreateReleaseGroupReleasesExecute(r ApiCreateReleaseGroupReleasesRequest) (*CreateReleaseGroup200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateReleaseGroup200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.CreateReleaseGroupReleases")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}/release"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createReleaseGroupReleasesRequest == nil {
		return localVarReturnValue, nil, reportError("createReleaseGroupReleasesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createReleaseGroupReleasesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenerateProjectGenerateAttributionSlug401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteReleaseGroupByIdRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
}

func (r ApiDeleteReleaseGroupByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteReleaseGroupByIdExecute(r)
}

/*
DeleteReleaseGroupById Method for DeleteReleaseGroupById

Delete a given release group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId
 @return ApiDeleteReleaseGroupByIdRequest
*/
func (a *ReleaseGroupsAPIService) DeleteReleaseGroupById(ctx context.Context, groupId int32) ApiDeleteReleaseGroupByIdRequest {
	return ApiDeleteReleaseGroupByIdRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *ReleaseGroupsAPIService) DeleteReleaseGroupByIdExecute(r ApiDeleteReleaseGroupByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.DeleteReleaseGroupById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenerateProjectGenerateAttributionSlug401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteReleaseGroupReleaseByIdRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
	projectGroupReleaseId int32
}

func (r ApiDeleteReleaseGroupReleaseByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteReleaseGroupReleaseByIdExecute(r)
}

/*
DeleteReleaseGroupReleaseById Method for DeleteReleaseGroupReleaseById

Delete a specific release within a release group, by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The ID of the release group
 @param projectGroupReleaseId The ID of the release
 @return ApiDeleteReleaseGroupReleaseByIdRequest
*/
func (a *ReleaseGroupsAPIService) DeleteReleaseGroupReleaseById(ctx context.Context, groupId int32, projectGroupReleaseId int32) ApiDeleteReleaseGroupReleaseByIdRequest {
	return ApiDeleteReleaseGroupReleaseByIdRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		projectGroupReleaseId: projectGroupReleaseId,
	}
}

// Execute executes the request
func (a *ReleaseGroupsAPIService) DeleteReleaseGroupReleaseByIdExecute(r ApiDeleteReleaseGroupReleaseByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.DeleteReleaseGroupReleaseById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}/release/{projectGroupReleaseId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectGroupReleaseId"+"}", url.PathEscape(parameterValueToString(r.projectGroupReleaseId, "projectGroupReleaseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeprecatedGetReleaseGroupReleasesRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
}

func (r ApiDeprecatedGetReleaseGroupReleasesRequest) Execute() ([]DeprecatedGetReleaseGroupReleases200ResponseInner, *http.Response, error) {
	return r.ApiService.DeprecatedGetReleaseGroupReleasesExecute(r)
}

/*
DeprecatedGetReleaseGroupReleases Method for DeprecatedGetReleaseGroupReleases

This endpoint is deprecated. Please use the paginated /project_group/{groupId}/releases endpoint instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The ID of the release group
 @return ApiDeprecatedGetReleaseGroupReleasesRequest

Deprecated
*/
func (a *ReleaseGroupsAPIService) DeprecatedGetReleaseGroupReleases(ctx context.Context, groupId int32) ApiDeprecatedGetReleaseGroupReleasesRequest {
	return ApiDeprecatedGetReleaseGroupReleasesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []DeprecatedGetReleaseGroupReleases200ResponseInner
// Deprecated
func (a *ReleaseGroupsAPIService) DeprecatedGetReleaseGroupReleasesExecute(r ApiDeprecatedGetReleaseGroupReleasesRequest) ([]DeprecatedGetReleaseGroupReleases200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DeprecatedGetReleaseGroupReleases200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.DeprecatedGetReleaseGroupReleases")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}/release"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllProjectsInReleaseGroupRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
}

func (r ApiGetAllProjectsInReleaseGroupRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetAllProjectsInReleaseGroupExecute(r)
}

/*
GetAllProjectsInReleaseGroup Method for GetAllProjectsInReleaseGroup

Returns a list of all of the projects in a given release group (regardless of release)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId
 @return ApiGetAllProjectsInReleaseGroupRequest
*/
func (a *ReleaseGroupsAPIService) GetAllProjectsInReleaseGroup(ctx context.Context, groupId int32) ApiGetAllProjectsInReleaseGroupRequest {
	return ApiGetAllProjectsInReleaseGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return []string
func (a *ReleaseGroupsAPIService) GetAllProjectsInReleaseGroupExecute(r ApiGetAllProjectsInReleaseGroupRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.GetAllProjectsInReleaseGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}/all_projects"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllReleaseGroupTeamsRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
}

func (r ApiGetAllReleaseGroupTeamsRequest) Execute() (*GetAllReleaseGroupTeams200Response, *http.Response, error) {
	return r.ApiService.GetAllReleaseGroupTeamsExecute(r)
}

/*
GetAllReleaseGroupTeams Method for GetAllReleaseGroupTeams

Returns a list of all of the teams assigned to a given release group, and a totalCount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId
 @return ApiGetAllReleaseGroupTeamsRequest
*/
func (a *ReleaseGroupsAPIService) GetAllReleaseGroupTeams(ctx context.Context, groupId int32) ApiGetAllReleaseGroupTeamsRequest {
	return ApiGetAllReleaseGroupTeamsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return GetAllReleaseGroupTeams200Response
func (a *ReleaseGroupsAPIService) GetAllReleaseGroupTeamsExecute(r ApiGetAllReleaseGroupTeamsRequest) (*GetAllReleaseGroupTeams200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllReleaseGroupTeams200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.GetAllReleaseGroupTeams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}/teams"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReleaseGroupAttributionReportStatusRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	taskId int32
}

func (r ApiGetReleaseGroupAttributionReportStatusRequest) Execute() (*GetReleaseGroupAttributionReportStatus200Response, *http.Response, error) {
	return r.ApiService.GetReleaseGroupAttributionReportStatusExecute(r)
}

/*
GetReleaseGroupAttributionReportStatus Method for GetReleaseGroupAttributionReportStatus

Check the status of a Release Group attribution report.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId
 @return ApiGetReleaseGroupAttributionReportStatusRequest
*/
func (a *ReleaseGroupsAPIService) GetReleaseGroupAttributionReportStatus(ctx context.Context, taskId int32) ApiGetReleaseGroupAttributionReportStatusRequest {
	return ApiGetReleaseGroupAttributionReportStatusRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return GetReleaseGroupAttributionReportStatus200Response
func (a *ReleaseGroupsAPIService) GetReleaseGroupAttributionReportStatusExecute(r ApiGetReleaseGroupAttributionReportStatusRequest) (*GetReleaseGroupAttributionReportStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetReleaseGroupAttributionReportStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.GetReleaseGroupAttributionReportStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/attribution/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReleaseGroupByIdRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
}

func (r ApiGetReleaseGroupByIdRequest) Execute() (*GetReleaseGroupById200Response, *http.Response, error) {
	return r.ApiService.GetReleaseGroupByIdExecute(r)
}

/*
GetReleaseGroupById Method for GetReleaseGroupById

Get a release group by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId
 @return ApiGetReleaseGroupByIdRequest
*/
func (a *ReleaseGroupsAPIService) GetReleaseGroupById(ctx context.Context, groupId int32) ApiGetReleaseGroupByIdRequest {
	return ApiGetReleaseGroupByIdRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return GetReleaseGroupById200Response
func (a *ReleaseGroupsAPIService) GetReleaseGroupByIdExecute(r ApiGetReleaseGroupByIdRequest) (*GetReleaseGroupById200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetReleaseGroupById200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.GetReleaseGroupById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReleaseGroupReleaseByIdRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
	projectGroupReleaseId int32
}

func (r ApiGetReleaseGroupReleaseByIdRequest) Execute() ([]GetReleaseGroupReleaseById200ResponseInner, *http.Response, error) {
	return r.ApiService.GetReleaseGroupReleaseByIdExecute(r)
}

/*
GetReleaseGroupReleaseById Method for GetReleaseGroupReleaseById

Get a specific release within a release group, by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The ID of the release group
 @param projectGroupReleaseId The ID of the release
 @return ApiGetReleaseGroupReleaseByIdRequest
*/
func (a *ReleaseGroupsAPIService) GetReleaseGroupReleaseById(ctx context.Context, groupId int32, projectGroupReleaseId int32) ApiGetReleaseGroupReleaseByIdRequest {
	return ApiGetReleaseGroupReleaseByIdRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		projectGroupReleaseId: projectGroupReleaseId,
	}
}

// Execute executes the request
//  @return []GetReleaseGroupReleaseById200ResponseInner
func (a *ReleaseGroupsAPIService) GetReleaseGroupReleaseByIdExecute(r ApiGetReleaseGroupReleaseByIdRequest) ([]GetReleaseGroupReleaseById200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetReleaseGroupReleaseById200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.GetReleaseGroupReleaseById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}/release/{projectGroupReleaseId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectGroupReleaseId"+"}", url.PathEscape(parameterValueToString(r.projectGroupReleaseId, "projectGroupReleaseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReleaseGroupReleaseLicensesRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
	projectGroupReleaseId int32
}

func (r ApiGetReleaseGroupReleaseLicensesRequest) Execute() (*map[string]GetReleaseGroupReleaseLicenses200ResponseValue, *http.Response, error) {
	return r.ApiService.GetReleaseGroupReleaseLicensesExecute(r)
}

/*
GetReleaseGroupReleaseLicenses Method for GetReleaseGroupReleaseLicenses

Get the licenses for a given release

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The ID of the release group
 @param projectGroupReleaseId The ID of the release
 @return ApiGetReleaseGroupReleaseLicensesRequest
*/
func (a *ReleaseGroupsAPIService) GetReleaseGroupReleaseLicenses(ctx context.Context, groupId int32, projectGroupReleaseId int32) ApiGetReleaseGroupReleaseLicensesRequest {
	return ApiGetReleaseGroupReleaseLicensesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		projectGroupReleaseId: projectGroupReleaseId,
	}
}

// Execute executes the request
//  @return map[string]GetReleaseGroupReleaseLicenses200ResponseValue
func (a *ReleaseGroupsAPIService) GetReleaseGroupReleaseLicensesExecute(r ApiGetReleaseGroupReleaseLicensesRequest) (*map[string]GetReleaseGroupReleaseLicenses200ResponseValue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]GetReleaseGroupReleaseLicenses200ResponseValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.GetReleaseGroupReleaseLicenses")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}/release/{projectGroupReleaseId}/licenses"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectGroupReleaseId"+"}", url.PathEscape(parameterValueToString(r.projectGroupReleaseId, "projectGroupReleaseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/x-ndjson"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReleaseGroupReleaseObligationsRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
	projectGroupReleaseId int32
}

func (r ApiGetReleaseGroupReleaseObligationsRequest) Execute() (*map[string][]GetReleaseGroupReleaseObligations200ResponseValueInner, *http.Response, error) {
	return r.ApiService.GetReleaseGroupReleaseObligationsExecute(r)
}

/*
GetReleaseGroupReleaseObligations Method for GetReleaseGroupReleaseObligations

Get the license obligations for a given release

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The ID of the release group
 @param projectGroupReleaseId The ID of the release
 @return ApiGetReleaseGroupReleaseObligationsRequest
*/
func (a *ReleaseGroupsAPIService) GetReleaseGroupReleaseObligations(ctx context.Context, groupId int32, projectGroupReleaseId int32) ApiGetReleaseGroupReleaseObligationsRequest {
	return ApiGetReleaseGroupReleaseObligationsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		projectGroupReleaseId: projectGroupReleaseId,
	}
}

// Execute executes the request
//  @return map[string][]GetReleaseGroupReleaseObligations200ResponseValueInner
func (a *ReleaseGroupsAPIService) GetReleaseGroupReleaseObligationsExecute(r ApiGetReleaseGroupReleaseObligationsRequest) (*map[string][]GetReleaseGroupReleaseObligations200ResponseValueInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string][]GetReleaseGroupReleaseObligations200ResponseValueInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.GetReleaseGroupReleaseObligations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}/release/{projectGroupReleaseId}/obligations"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectGroupReleaseId"+"}", url.PathEscape(parameterValueToString(r.projectGroupReleaseId, "projectGroupReleaseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReleaseGroupReleaseRevisionsRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
	projectGroupReleaseId int32
}

func (r ApiGetReleaseGroupReleaseRevisionsRequest) Execute() ([]GetReleaseGroupReleaseRevisions200ResponseInner, *http.Response, error) {
	return r.ApiService.GetReleaseGroupReleaseRevisionsExecute(r)
}

/*
GetReleaseGroupReleaseRevisions Method for GetReleaseGroupReleaseRevisions

Get the revisions for a given release

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The ID of the release group
 @param projectGroupReleaseId The ID of the release
 @return ApiGetReleaseGroupReleaseRevisionsRequest
*/
func (a *ReleaseGroupsAPIService) GetReleaseGroupReleaseRevisions(ctx context.Context, groupId int32, projectGroupReleaseId int32) ApiGetReleaseGroupReleaseRevisionsRequest {
	return ApiGetReleaseGroupReleaseRevisionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		projectGroupReleaseId: projectGroupReleaseId,
	}
}

// Execute executes the request
//  @return []GetReleaseGroupReleaseRevisions200ResponseInner
func (a *ReleaseGroupsAPIService) GetReleaseGroupReleaseRevisionsExecute(r ApiGetReleaseGroupReleaseRevisionsRequest) ([]GetReleaseGroupReleaseRevisions200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetReleaseGroupReleaseRevisions200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.GetReleaseGroupReleaseRevisions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}/release/{projectGroupReleaseId}/revisions"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectGroupReleaseId"+"}", url.PathEscape(parameterValueToString(r.projectGroupReleaseId, "projectGroupReleaseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReleaseGroupReleaseScansRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
	projectGroupReleaseId int32
}

func (r ApiGetReleaseGroupReleaseScansRequest) Execute() (*GetReleaseGroupReleaseScans200Response, *http.Response, error) {
	return r.ApiService.GetReleaseGroupReleaseScansExecute(r)
}

/*
GetReleaseGroupReleaseScans Method for GetReleaseGroupReleaseScans

Get the release scans for a given release

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The ID of the release group
 @param projectGroupReleaseId The ID of the release
 @return ApiGetReleaseGroupReleaseScansRequest
*/
func (a *ReleaseGroupsAPIService) GetReleaseGroupReleaseScans(ctx context.Context, groupId int32, projectGroupReleaseId int32) ApiGetReleaseGroupReleaseScansRequest {
	return ApiGetReleaseGroupReleaseScansRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		projectGroupReleaseId: projectGroupReleaseId,
	}
}

// Execute executes the request
//  @return GetReleaseGroupReleaseScans200Response
func (a *ReleaseGroupsAPIService) GetReleaseGroupReleaseScansExecute(r ApiGetReleaseGroupReleaseScansRequest) (*GetReleaseGroupReleaseScans200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetReleaseGroupReleaseScans200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.GetReleaseGroupReleaseScans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}/release/{projectGroupReleaseId}/scans"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectGroupReleaseId"+"}", url.PathEscape(parameterValueToString(r.projectGroupReleaseId, "projectGroupReleaseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReleaseGroupReleaseSummaryRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
	projectGroupReleaseId int32
}

func (r ApiGetReleaseGroupReleaseSummaryRequest) Execute() (*GetReleaseGroupReleaseSummary200Response, *http.Response, error) {
	return r.ApiService.GetReleaseGroupReleaseSummaryExecute(r)
}

/*
GetReleaseGroupReleaseSummary Method for GetReleaseGroupReleaseSummary

Get a summary of release group issue, project and dependency counts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The ID of the release group
 @param projectGroupReleaseId The ID of the release
 @return ApiGetReleaseGroupReleaseSummaryRequest
*/
func (a *ReleaseGroupsAPIService) GetReleaseGroupReleaseSummary(ctx context.Context, groupId int32, projectGroupReleaseId int32) ApiGetReleaseGroupReleaseSummaryRequest {
	return ApiGetReleaseGroupReleaseSummaryRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		projectGroupReleaseId: projectGroupReleaseId,
	}
}

// Execute executes the request
//  @return GetReleaseGroupReleaseSummary200Response
func (a *ReleaseGroupsAPIService) GetReleaseGroupReleaseSummaryExecute(r ApiGetReleaseGroupReleaseSummaryRequest) (*GetReleaseGroupReleaseSummary200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetReleaseGroupReleaseSummary200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.GetReleaseGroupReleaseSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}/release/{projectGroupReleaseId}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectGroupReleaseId"+"}", url.PathEscape(parameterValueToString(r.projectGroupReleaseId, "projectGroupReleaseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReleaseGroupReleasesRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
	count *int32
	page *int32
	search *string
}

func (r ApiGetReleaseGroupReleasesRequest) Count(count int32) ApiGetReleaseGroupReleasesRequest {
	r.count = &count
	return r
}

func (r ApiGetReleaseGroupReleasesRequest) Page(page int32) ApiGetReleaseGroupReleasesRequest {
	r.page = &page
	return r
}

func (r ApiGetReleaseGroupReleasesRequest) Search(search string) ApiGetReleaseGroupReleasesRequest {
	r.search = &search
	return r
}

func (r ApiGetReleaseGroupReleasesRequest) Execute() (*GetReleaseGroupReleases200Response, *http.Response, error) {
	return r.ApiService.GetReleaseGroupReleasesExecute(r)
}

/*
GetReleaseGroupReleases Method for GetReleaseGroupReleases

Returns a paginated list of releases for a given release group. You must have permission to view this release group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The ID of the release group
 @return ApiGetReleaseGroupReleasesRequest
*/
func (a *ReleaseGroupsAPIService) GetReleaseGroupReleases(ctx context.Context, groupId int32) ApiGetReleaseGroupReleasesRequest {
	return ApiGetReleaseGroupReleasesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return GetReleaseGroupReleases200Response
func (a *ReleaseGroupsAPIService) GetReleaseGroupReleasesExecute(r ApiGetReleaseGroupReleasesRequest) (*GetReleaseGroupReleases200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetReleaseGroupReleases200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.GetReleaseGroupReleases")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}/releases"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueueReleaseGroupAttributionReportRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
	releaseId int32
	format string
	includeDeepDependencies *bool
	includeDirectDependencies *bool
	includeLicenseList *bool
	includeLicenseScan *bool
	includeProjectLicense *bool
	includeCopyrightList *bool
	includeFileMatches *bool
	includeOpenVulnerabilities *bool
	includeClosedVulnerabilities *bool
	includeDependencySummary *bool
	includeLicenseHeaders *bool
	dependencyInfoOptions *[]string
}

func (r ApiQueueReleaseGroupAttributionReportRequest) IncludeDeepDependencies(includeDeepDependencies bool) ApiQueueReleaseGroupAttributionReportRequest {
	r.includeDeepDependencies = &includeDeepDependencies
	return r
}

func (r ApiQueueReleaseGroupAttributionReportRequest) IncludeDirectDependencies(includeDirectDependencies bool) ApiQueueReleaseGroupAttributionReportRequest {
	r.includeDirectDependencies = &includeDirectDependencies
	return r
}

func (r ApiQueueReleaseGroupAttributionReportRequest) IncludeLicenseList(includeLicenseList bool) ApiQueueReleaseGroupAttributionReportRequest {
	r.includeLicenseList = &includeLicenseList
	return r
}

func (r ApiQueueReleaseGroupAttributionReportRequest) IncludeLicenseScan(includeLicenseScan bool) ApiQueueReleaseGroupAttributionReportRequest {
	r.includeLicenseScan = &includeLicenseScan
	return r
}

func (r ApiQueueReleaseGroupAttributionReportRequest) IncludeProjectLicense(includeProjectLicense bool) ApiQueueReleaseGroupAttributionReportRequest {
	r.includeProjectLicense = &includeProjectLicense
	return r
}

func (r ApiQueueReleaseGroupAttributionReportRequest) IncludeCopyrightList(includeCopyrightList bool) ApiQueueReleaseGroupAttributionReportRequest {
	r.includeCopyrightList = &includeCopyrightList
	return r
}

func (r ApiQueueReleaseGroupAttributionReportRequest) IncludeFileMatches(includeFileMatches bool) ApiQueueReleaseGroupAttributionReportRequest {
	r.includeFileMatches = &includeFileMatches
	return r
}

func (r ApiQueueReleaseGroupAttributionReportRequest) IncludeOpenVulnerabilities(includeOpenVulnerabilities bool) ApiQueueReleaseGroupAttributionReportRequest {
	r.includeOpenVulnerabilities = &includeOpenVulnerabilities
	return r
}

func (r ApiQueueReleaseGroupAttributionReportRequest) IncludeClosedVulnerabilities(includeClosedVulnerabilities bool) ApiQueueReleaseGroupAttributionReportRequest {
	r.includeClosedVulnerabilities = &includeClosedVulnerabilities
	return r
}

func (r ApiQueueReleaseGroupAttributionReportRequest) IncludeDependencySummary(includeDependencySummary bool) ApiQueueReleaseGroupAttributionReportRequest {
	r.includeDependencySummary = &includeDependencySummary
	return r
}

func (r ApiQueueReleaseGroupAttributionReportRequest) IncludeLicenseHeaders(includeLicenseHeaders bool) ApiQueueReleaseGroupAttributionReportRequest {
	r.includeLicenseHeaders = &includeLicenseHeaders
	return r
}

func (r ApiQueueReleaseGroupAttributionReportRequest) DependencyInfoOptions(dependencyInfoOptions []string) ApiQueueReleaseGroupAttributionReportRequest {
	r.dependencyInfoOptions = &dependencyInfoOptions
	return r
}

func (r ApiQueueReleaseGroupAttributionReportRequest) Execute() (*QueueReleaseGroupAttributionReport200Response, *http.Response, error) {
	return r.ApiService.QueueReleaseGroupAttributionReportExecute(r)
}

/*
QueueReleaseGroupAttributionReport Method for QueueReleaseGroupAttributionReport

Submit a Release Group attribution report for processing.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The ID of the release group
 @param releaseId
 @param format
 @return ApiQueueReleaseGroupAttributionReportRequest
*/
func (a *ReleaseGroupsAPIService) QueueReleaseGroupAttributionReport(ctx context.Context, groupId int32, releaseId int32, format string) ApiQueueReleaseGroupAttributionReportRequest {
	return ApiQueueReleaseGroupAttributionReportRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		releaseId: releaseId,
		format: format,
	}
}

// Execute executes the request
//  @return QueueReleaseGroupAttributionReport200Response
func (a *ReleaseGroupsAPIService) QueueReleaseGroupAttributionReportExecute(r ApiQueueReleaseGroupAttributionReportRequest) (*QueueReleaseGroupAttributionReport200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueueReleaseGroupAttributionReport200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.QueueReleaseGroupAttributionReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}/release/{releaseId}/attribution/{format}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"releaseId"+"}", url.PathEscape(parameterValueToString(r.releaseId, "releaseId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", url.PathEscape(parameterValueToString(r.format, "format")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeDeepDependencies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDeepDependencies", r.includeDeepDependencies, "form", "")
	}
	if r.includeDirectDependencies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDirectDependencies", r.includeDirectDependencies, "form", "")
	}
	if r.includeLicenseList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLicenseList", r.includeLicenseList, "form", "")
	}
	if r.includeLicenseScan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLicenseScan", r.includeLicenseScan, "form", "")
	}
	if r.includeProjectLicense != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeProjectLicense", r.includeProjectLicense, "form", "")
	}
	if r.includeCopyrightList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCopyrightList", r.includeCopyrightList, "form", "")
	}
	if r.includeFileMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeFileMatches", r.includeFileMatches, "form", "")
	}
	if r.includeOpenVulnerabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOpenVulnerabilities", r.includeOpenVulnerabilities, "form", "")
	}
	if r.includeClosedVulnerabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeClosedVulnerabilities", r.includeClosedVulnerabilities, "form", "")
	}
	if r.includeDependencySummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDependencySummary", r.includeDependencySummary, "form", "")
	}
	if r.includeLicenseHeaders != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLicenseHeaders", r.includeLicenseHeaders, "form", "")
	}
	if r.dependencyInfoOptions != nil {
		t := *r.dependencyInfoOptions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "dependencyInfoOptions[]", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "dependencyInfoOptions[]", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateReleaseGroupByIdRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
	updateReleaseGroupByIdRequest *UpdateReleaseGroupByIdRequest
}

func (r ApiUpdateReleaseGroupByIdRequest) UpdateReleaseGroupByIdRequest(updateReleaseGroupByIdRequest UpdateReleaseGroupByIdRequest) ApiUpdateReleaseGroupByIdRequest {
	r.updateReleaseGroupByIdRequest = &updateReleaseGroupByIdRequest
	return r
}

func (r ApiUpdateReleaseGroupByIdRequest) Execute() (*CreateReleaseGroup200Response, *http.Response, error) {
	return r.ApiService.UpdateReleaseGroupByIdExecute(r)
}

/*
UpdateReleaseGroupById Method for UpdateReleaseGroupById

Update a given release group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId
 @return ApiUpdateReleaseGroupByIdRequest
*/
func (a *ReleaseGroupsAPIService) UpdateReleaseGroupById(ctx context.Context, groupId int32) ApiUpdateReleaseGroupByIdRequest {
	return ApiUpdateReleaseGroupByIdRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
//  @return CreateReleaseGroup200Response
func (a *ReleaseGroupsAPIService) UpdateReleaseGroupByIdExecute(r ApiUpdateReleaseGroupByIdRequest) (*CreateReleaseGroup200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateReleaseGroup200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.UpdateReleaseGroupById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateReleaseGroupByIdRequest == nil {
		return localVarReturnValue, nil, reportError("updateReleaseGroupByIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateReleaseGroupByIdRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GenerateProjectGenerateAttributionSlug401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateReleaseGroupReleaseByIdRequest struct {
	ctx context.Context
	ApiService *ReleaseGroupsAPIService
	groupId int32
	projectGroupReleaseId int32
	updateReleaseGroupReleaseByIdRequest *UpdateReleaseGroupReleaseByIdRequest
}

func (r ApiUpdateReleaseGroupReleaseByIdRequest) UpdateReleaseGroupReleaseByIdRequest(updateReleaseGroupReleaseByIdRequest UpdateReleaseGroupReleaseByIdRequest) ApiUpdateReleaseGroupReleaseByIdRequest {
	r.updateReleaseGroupReleaseByIdRequest = &updateReleaseGroupReleaseByIdRequest
	return r
}

func (r ApiUpdateReleaseGroupReleaseByIdRequest) Execute() (*CreateReleaseGroup200Response, *http.Response, error) {
	return r.ApiService.UpdateReleaseGroupReleaseByIdExecute(r)
}

/*
UpdateReleaseGroupReleaseById Method for UpdateReleaseGroupReleaseById

Update a specific release within a release group, by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The ID of the release group
 @param projectGroupReleaseId The ID of the release
 @return ApiUpdateReleaseGroupReleaseByIdRequest
*/
func (a *ReleaseGroupsAPIService) UpdateReleaseGroupReleaseById(ctx context.Context, groupId int32, projectGroupReleaseId int32) ApiUpdateReleaseGroupReleaseByIdRequest {
	return ApiUpdateReleaseGroupReleaseByIdRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		projectGroupReleaseId: projectGroupReleaseId,
	}
}

// Execute executes the request
//  @return CreateReleaseGroup200Response
func (a *ReleaseGroupsAPIService) UpdateReleaseGroupReleaseByIdExecute(r ApiUpdateReleaseGroupReleaseByIdRequest) (*CreateReleaseGroup200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateReleaseGroup200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleaseGroupsAPIService.UpdateReleaseGroupReleaseById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project_group/{groupId}/release/{projectGroupReleaseId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectGroupReleaseId"+"}", url.PathEscape(parameterValueToString(r.projectGroupReleaseId, "projectGroupReleaseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateReleaseGroupReleaseByIdRequest == nil {
		return localVarReturnValue, nil, reportError("updateReleaseGroupReleaseByIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateReleaseGroupReleaseByIdRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetGitHubAppInstallationUrl403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
